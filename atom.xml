<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://childlike2333.github.io</id>
    <title>Childlike</title>
    <updated>2020-04-06T04:26:34.443Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://childlike2333.github.io"/>
    <link rel="self" href="https://childlike2333.github.io/atom.xml"/>
    <subtitle>不忘初心 方得始终</subtitle>
    <logo>https://childlike2333.github.io/images/avatar.png</logo>
    <icon>https://childlike2333.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Childlike</rights>
    <entry>
        <title type="html"><![CDATA[07——Django实战]]></title>
        <id>https://childlike2333.github.io/post/07-django-shi-zhan/</id>
        <link href="https://childlike2333.github.io/post/07-django-shi-zhan/">
        </link>
        <updated>2020-04-06T02:33:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="项目创建及准备">项目创建及准备</h3>
<h4 id="创建">创建</h4>
<pre><code class="language-python"># 创建项目
django-admin startproject MPlat
# 创建app
python manage.py startapp machine

# 设置
# 1.安装app
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'machine',
]
# 2.allowed_hosts
ALLOWED_HOSTS = ['*']
# 3.templates_dir，并在路径下创建templates文件夹，及machine文件夹
'DIRS': [os.path.join(BASE_DIR,'templates')],
# 4.注释掉csrf
#'django.middleware.csrf.CsrfViewMiddleware',
# 5.汉化
LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
</code></pre>
<h4 id="数据库配置使用mysql">数据库配置使用mysql</h4>
<p>在数据库创建mplat</p>
<figure data-type="image" tabindex="1"><img src="https://childlike2333.github.io/post-images/1586142649396.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mplat',
        'USER': 'root',
        'PASSWORD':'root',
        'HOST':'192.168.1.3',
        'PORT':'3306',
    }
}

# 初始化数据库
python manage.py migrate
</code></pre>
<h4 id="后台密码创建">后台密码创建</h4>
<pre><code class="language-python">python manage.py createsuperuser
</code></pre>
<h3 id="模型设计及创建">模型设计及创建</h3>
<h4 id="user表">user表</h4>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>长度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>usernum</td>
<td>char</td>
<td>64</td>
<td>用户账号</td>
</tr>
<tr>
<td>passwd</td>
<td>char</td>
<td>64</td>
<td>用户密码</td>
</tr>
<tr>
<td>username</td>
<td>char</td>
<td>64</td>
<td>用户昵称</td>
</tr>
</tbody>
</table>
<h4 id="machine表">machine表</h4>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>长度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>ip</td>
<td>char</td>
<td>15</td>
<td>ip地址</td>
</tr>
<tr>
<td>user_id</td>
<td>foreiginkey</td>
<td></td>
<td>指向用户id</td>
</tr>
<tr>
<td>asset_num</td>
<td>char</td>
<td>64</td>
<td>资产编号</td>
</tr>
<tr>
<td>device_location</td>
<td>char</td>
<td>64</td>
<td>机柜位置</td>
</tr>
<tr>
<td>os</td>
<td>char</td>
<td>64</td>
<td>操作系统</td>
</tr>
<tr>
<td>create_time</td>
<td>time</td>
<td></td>
<td>创建时间</td>
</tr>
<tr>
<td>update_time</td>
<td>time</td>
<td></td>
<td>更新时间</td>
</tr>
</tbody>
</table>
<h4 id="models表">models表</h4>
<pre><code class="language-python">from django.db import models

# Create your models here.
class User(models.Model):
    class Meta:
        db_table = 'user'

    usernum = models.CharField(max_length=64,db_column='usernum')
    passwd = models.CharField(max_length=64,db_column='passwd')
    username = models.CharField(max_length=64,db_column='username')


class Machine(models.Model):
    class Meta:
        db_table = 'machine'

    ip = models.CharField(max_length=15,db_column='ip')
    user_id = models.ForeignKey(User,db_column='user_id',on_delete=models.CASCADE)
    asset_num = models.CharField(max_length=64, db_column='asset_num')
    device_location = models.CharField(max_length=64, db_column='device_location')
    os = models.CharField(max_length=64, db_column='os')
    create_time = models.DateTimeField(db_column='create_time')
    update_time = models.DateTimeField(db_column='update_time')
</code></pre>
<h4 id="admin">admin</h4>
<pre><code class="language-python">from django.contrib import admin

# Register your models here.
from machine.models import *

class UserInfoAdmin(admin.ModelAdmin):

    list_display = ['id','usernum','passwd','username']

class MachineInfoAdmin(admin.ModelAdmin):

    list_display = ['ip','user_id','asset_num','device_location','create_time','update_time']

admin.site.register(User,UserInfoAdmin)
admin.site.register(Machine,MachineInfoAdmin)
</code></pre>
<pre><code class="language-python">python manage.py makemigrations
python manage.py migrate	
</code></pre>
<h4 id="增加账号">增加账号</h4>
<p>增加两个账号密码 ming  和 hong</p>
<h3 id="登陆功能">登陆功能</h3>
<h4 id="路径准备">路径准备</h4>
<h5 id="根目录下的urls">根目录下的urls</h5>
<pre><code class="language-python">from django.contrib import admin
from django.urls import path
from django.conf.urls import include,url

urlpatterns = [
    path('admin/', admin.site.urls),
    url(r'^',include('machine.urls',namespace='machine')),
]
</code></pre>
<h5 id="machine下的url">machine下的url</h5>
<pre><code class="language-python">from django.conf.urls import url

from machine import views

app_name = 'machine'
urlpatterns = [
    url(r'^$',views.index,name='index'),
]
</code></pre>
<h5 id="view">view</h5>
<pre><code class="language-python">def index(request):
    return render(request,'index.html',{})
</code></pre>
<h5 id="indexhtml">index.html</h5>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
这是登陆界面
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="登陆页面">登陆页面</h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/layui/css/layui.css&quot; media=&quot;all&quot;&gt;
    &lt;title&gt;登录界面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;style type=&quot;text/css&quot;&gt;
    body {
        background-image: url(/static/images/login-bg.jpg);
    }
&lt;/style&gt;
&lt;div class=&quot;layui-col-xs6&quot;&gt;
    &lt;div class=&quot;grid-demo&quot;&gt;&amp;nbsp;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;layui-col-xs6&quot; style=&quot;padding-top: 15%;&quot;&gt;
    &lt;div style=&quot;width:50%;margin:0 auto;text-align: center&quot;&gt;
        &lt;form class=&quot;layui-form&quot; method=&quot;POST&quot; action=&quot;login&quot;&gt;
            &lt;div class=&quot;layui-form-item&quot; style=&quot;margin:0 auto&quot;&gt;
                &lt;div class=&quot;layui-input-inline&quot;&gt;
                    用户登录&lt;br&gt;&lt;br&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-form-item&quot;&gt;
                &lt;div class=&quot;layui-input-inline&quot;&gt;
                    &lt;input type=&quot;text&quot; name=&quot;title&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入账号&quot;
                           autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-form-item&quot;&gt;
                &lt;div class=&quot;layui-input-inline&quot;&gt;
                    &lt;input type=&quot;password&quot; name=&quot;password&quot; required lay-verify=&quot;required&quot; placeholder=&quot;请输入密码&quot;
                           autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;layui-form-item&quot; style=&quot;margin:0 auto&quot;&gt;
                &lt;div class=&quot;layui-input-inline&quot;&gt;
                    &lt;button class=&quot;layui-btn&quot; lay-submit lay-filter=&quot;formDemo&quot; style=&quot;padding:0 42%&quot;&gt;登录&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/form&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script src=&quot;/static/layui/layui.all.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    layui.use('form', function () {
        var form = layui.form;
        //监听提交
        form.on('submit(formDemo)', function (data) {
            layer.msg(JSON.stringify(data.field));
            
            return false;
        });
    });
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>到这一步，我们简单登陆页面就写完了。我们接下来要继续完成，登陆界面的功能。</p>
<p>比如我点击登陆后，我们要进行账号密码的校验及校验完成后的跳转。我们先简单顶一个跳转页面。在模板下创建文件。</p>
<pre><code class="language-python">def machine(request):
    return render(request,'machine/machine.html',{})
</code></pre>
<pre><code class="language-python">urlpatterns = [
    url(r'^$',views.index,name='index'),
    url(r'^machine',views.machine,name='machine'),
]
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
这是机器展示页面
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="登陆的接口">登陆的接口</h4>
<p>这里我们需要定义登录的接口。login</p>
<pre><code class="language-python">url(r'^login$',views.login,name='login')
</code></pre>
<pre><code class="language-python">from django.http import JsonResponse


def login(request):
    return JsonResponse({})
</code></pre>
<p>我们在index,html中使用jquery,将登陆信息传到后台，进行登陆校验，校验通过返回1，前端接收到1后进行跳转，跳转到指定的页面。</p>
<pre><code class="language-python">import json
from machine.models import *

def login(request):
    field = request.POST.get('field')
    field = json.loads(field)
    usernum = field['usernum']
    password = field['password']

    # 和数据库中的对比，检查是否正确
    obj = User.objects.filter(usernum=usernum)
    if len(obj) == 0:
        return JsonResponse({'message':0})
    elif obj[0].passwd != password:
        return JsonResponse({'message':0})
    else:
        return JsonResponse({'message':1})
</code></pre>
<pre><code class="language-html">&lt;script src=&quot;/static/jquery-1.12.4.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    layui.use('form', function () {
        var form = layui.form;
        //监听提交
        form.on('submit(formDemo)', function (data) {
            //layer.msg(JSON.stringify(data.field));
            var field = JSON.stringify(data.field)
               $.post(
                           '{% url 'machine:login' %}',
                           {
                               field:field,
                            },
                           function (data) {//修改成功后需要关闭弹窗并且重载表格
                               if (data.message == 1){
                                   layer.msg('登录成功', {icon: 1,time:1000})
                                     setTimeout(function(){window.location.href = 'machine';},1000)
                               }else if (data.message == 0){
                                   layer.msg('用户名或者密码错误', {icon: 5,time:1000})
                               }
                           }
               )
            return false;
        });
    });
&lt;/script&gt;
</code></pre>
<h3 id="机器管理页面">机器管理页面</h3>
<h4 id="框架搭建">框架搭建</h4>
<p>机器管理页面就是我们的核心页面。由登陆跳转到这里后，直接展示我们的机器管理平台。</p>
<p>先从layui首页复制过来，看看它的样子</p>
<pre><code class="language-python">def home(request):
    return render(request,'home.html',{})

url(r'^home$',views.home,name='home')
</code></pre>
<p>删除掉部分内容，发现主体框架没有移动过去，故修改之。添加父类模板标签</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;
  &lt;title&gt;MPlat&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/layui/css/layui.css&quot;&gt;
&lt;/head&gt;
&lt;body class=&quot;layui-layout-body&quot;&gt;
&lt;div class=&quot;layui-layout layui-layout-admin&quot;&gt;
  &lt;div class=&quot;layui-header&quot;&gt;
    &lt;div class=&quot;layui-logo&quot;&gt;MPlat&lt;/div&gt;
    &lt;!-- 头部区域（可配合layui已有的水平导航） --&gt;
    &lt;ul class=&quot;layui-nav layui-layout-left&quot;&gt;
      &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;&quot;&gt;控制台&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul class=&quot;layui-nav layui-layout-right&quot;&gt;
      &lt;li class=&quot;layui-nav-item&quot;&gt;
        &lt;a href=&quot;javascript:;&quot;&gt;
          &lt;img src=&quot;http://t.cn/RCzsdCq&quot; class=&quot;layui-nav-img&quot;&gt;
          贤心
        &lt;/a&gt;
        &lt;dl class=&quot;layui-nav-child&quot;&gt;
          &lt;dd&gt;&lt;a href=&quot;&quot;&gt;基本资料&lt;/a&gt;&lt;/dd&gt;
          &lt;dd&gt;&lt;a href=&quot;&quot;&gt;安全设置&lt;/a&gt;&lt;/dd&gt;
        &lt;/dl&gt;
      &lt;/li&gt;
      &lt;li class=&quot;layui-nav-item&quot;&gt;&lt;a href=&quot;&quot;&gt;退出&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;

  &lt;div class=&quot;layui-body&quot; style=&quot;left: 15px ; right:0px&quot;&gt;
    {% block home%}
      {% endblock home%}

  &lt;/div&gt;

  &lt;div class=&quot;layui-footer&quot; style=&quot;left: 0px;&quot;&gt;
    &lt;!-- 底部固定区域 --&gt;
    © MPlat.com
  &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code>{% extends 'home.html'%}
{%block home%}
这是机器界面
{%endblock home%}
</code></pre>
<figure data-type="image" tabindex="2"><img src="file://C:%5CUsers%5C86189%5CDocuments%5CGridea%5Cpost-images%5CMPlat.zip" alt="MPlat.zip" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[06——Django基础]]></title>
        <id>https://childlike2333.github.io/post/06-django-ji-chu/</id>
        <link href="https://childlike2333.github.io/post/06-django-ji-chu/">
        </link>
        <updated>2020-04-06T02:32:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="django简介">Django简介</h3>
<h4 id="什么是软件框架">什么是软件框架</h4>
<p>举个简单的例子，对于一个公司来说，公司中有各个职能部门，每个部门各司其职，通过部门之间的配合来完成工作，这些部门就形成了一个公司的组织架构。从某种意义上来说，公司就是一种框架。那么对应到软件设计上来说，软件框架是由其中的各个模块组成的，每个模块负责特定的功能，模块与模块之间相互协作来完成软件开发。</p>
<p>一个公司，它是针对某一市场而成立的，而软件框架的设计，也是针对某一类软件问题而设计的，其目的主要是提高软件开发效率。</p>
<h4 id="什么是mvc框架">什么是MVC框架</h4>
<p>MVC的全拼为Model-View-Controller，一种软件设计模式，是为了将传统的输入（input）、处理（processing）、输出（output）任务运用到图形化用户交互模型中而设计的。随着标准输入输出设备的出现，开发人员只需要将精力集中在业务逻辑的分析与实现上。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。现在虽然不再使用原来的分工方式，但是这种分工的思想被沿用下来，广泛应用于软件工程中，是一种典型并且应用广泛的软件架构模式。后来，MVC的思想被应用在了Ｗeb开发方面，被称为Ｗeb MVC框架。</p>
<p>MVC框架的核心思想是：解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容。</p>
<p>当前主流的开发语言如Java、PHP、Python中都有MVC框架。</p>
<figure data-type="image" tabindex="1"><img src="https://childlike2333.github.io/post-images/1586142243982.png" alt="" loading="lazy"></figure>
<h4 id="web-mvc各部分的功能">Ｗeb MVC各部分的功能</h4>
<p>M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。</p>
<p>V全拼为View，用于封装结果，生成页面展示的html内容。</p>
<p>C全拼为Controller，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。</p>
<p>Django框架遵循MVC设计，并且有一个专有名词：MVT</p>
<h4 id="mvt各部分的功能">MVT各部分的功能</h4>
<p>M全拼为Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理。</p>
<p>V全拼为View，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。</p>
<p>T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html。</p>
<figure data-type="image" tabindex="2"><img src="https://childlike2333.github.io/post-images/1586142287009.png" alt="" loading="lazy"></figure>
<h3 id="第一个django程序">第一个Django程序</h3>
<h4 id="安装django环境">安装Django环境</h4>
<p>pip install django</p>
<ul>
<li>创建项目</li>
</ul>
<pre><code class="language-python">django-admin startproject SMS(学校管理系统)
</code></pre>
<p>创建应用，这里应用的概念就相当于一个一个的功能模块，比如在一个电商网站中，用户管理、购物车、支付等等，就是一个一个的功能模块，我们用应用的概念将之区分开。</p>
<ul>
<li>创建应用</li>
</ul>
<pre><code>python manage.py startapp studentToClass
</code></pre>
<h4 id="目录结构介绍">目录结构介绍</h4>
<ul>
<li>
<p>*init.py_*是一个空文件，表示当前目录booktest可以当作一个python包使用。</p>
</li>
<li>
<p>tests.py文件用于开发测试用例，在实际开发中会有专门的测试人员，这个事情不需要我们来做。</p>
</li>
<li>
<p>models.py文件跟数据库操作相关。</p>
</li>
<li>
<p>views.py文件跟接收浏览器请求，进行处理，返回页面相关。</p>
</li>
<li>
<p>admin.py文件跟网站的后台管理相关。</p>
</li>
<li>
<p>migrations(与数据库相关)文件夹之后给大家介绍。</p>
</li>
</ul>
<p>注册app</p>
<p>settings.py中注册</p>
<p>INSTALLED_APPS</p>
<p>简易开发服务器</p>
<p>在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。</p>
<p>运行服务器命令如下：</p>
<pre><code>python manage.py runserver ip:端口
例：
python manage.py runserver
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://childlike2333.github.io/post-images/1586142318732.png" alt="" loading="lazy"></figure>
<h4 id="模型设计">模型设计</h4>
<p>我们之前操作数据库是通过写sql语句，那么能不能不写sql语句就可以操作数据库呢？ 可以，就是通过接下来要给大家讲的<strong>ORM框架</strong>。</p>
<p>ORM框架</p>
<p>O是object，也就<strong>类对象</strong>的意思，R是relation，翻译成中文是关系，也就是关系数据库中<strong>数据表</strong>的意思，M是mapping，是<strong>映射</strong>的意思。在ORM框架中，它帮我们把类和数据表进行了一个映射，可以让我们<strong>通过类和类对象就能操作它所对应的表格中的数据</strong>。ORM框架还有一个功能，它可以<strong>根据我们设计的类自动帮我们生成数据库中的表格</strong>，省去了我们自己建表的过程。</p>
<p>django中内嵌了ORM框架，不需要直接面向数据库编程，而是定义模型类，通过模型类和对象完成数据表的增删改查操作。</p>
<p>使用django进行数据库开发的步骤如下：</p>
<ul>
<li>1.在models.py中定义模型类</li>
<li>2.迁移</li>
<li>3.通过类和对象完成数据增删改查操作</li>
</ul>
<p>1.定义模型类</p>
<p>模型类定义在models.py文件中，继承自models.Model类。</p>
<blockquote>
<p>说明：不需要定义主键列，在生成时会自动添加，并且值为自动增长。</p>
</blockquote>
<p>设计班级类</p>
<p>类名： classInfo</p>
<p>班级名称：class_name  六年级一班</p>
<p>班级号：class_id 601</p>
<p>学生类： studentInfo</p>
<p>学生学号：student_id</p>
<p>学生姓名：student_name</p>
<p>学生生日：student_birth</p>
<pre><code class="language-python">from django.db import models

# Create your models here.
class classInfo(models.Model):
    class_id = models.IntegerField()
    class_name = models.CharField(max_length=20)


class studentInfo(models.Model):
    student_id = models.IntegerField()
    student_name = models.CharField(max_length=20)
    student_birth = models.DateField()
    belong_class = models.ForeignKey('classInfo')
</code></pre>
<h4 id="生成迁移">生成迁移</h4>
<pre><code class="language-python">python manage.py makemigrations  #生成迁移
python manage.py migrate  # 迁移
</code></pre>
<h4 id="后台管理系统">后台管理系统</h4>
<p>假设我们要设计一个新闻网站，我们需要编写展示给用户的页面，网页上展示的新闻信息是从哪里来的呢？<strong>是从数据库中查找到新闻的信息，然后把它展示在页面上</strong>。但是我们的网站上的新闻每天都要更新，这就意味着对数据库的增、删、改、查操作，那么我们需要每天写sql语句操作数据库吗?<br>
如果这样的话，是不是非常繁琐，所以我们可以设计一个页面，通过对这个页面的操作来实现对新闻数据库的增删改查操作。那么问题来了，老板说我们需要在建立一个新网站，是不是还要设计一个页面来实现对新网站数据库的增删改查操作，但是这样的页面具有一个很大的重复性，那有没有一种方法能够让我们很快的生成管理数据库表的页面呢？<strong>有，那就是我们接下来要给大家讲的Django的后台管理</strong>。Django能够根据定义的模型类自动地生成管理页面。</p>
<p>汉化</p>
<pre><code>LANGUAGE_CODE = 'zh-hans' #使用中国语言
TIME_ZONE = 'Asia/Shanghai' #使用中国上海时间
</code></pre>
<h5 id="创建管理员并登陆">创建管理员并登陆</h5>
<pre><code>python manage.py createsuperuser
python manage.py runserver
http://127.0.0.1:8000/admin/
</code></pre>
<p>注册模型类</p>
<pre><code>from django.contrib import admin
from booktest.models import BookInfo,HeroInfo

admin.site.register(classInfo)
admin.site.register(studentInfo)
</code></pre>
<p>自定义管理页面</p>
<pre><code class="language-python">from django.contrib import admin
from studentToClass.models import *

class classInfoAdmin(admin.ModelAdmin):
    list_display = ['id', 'class_id', 'class_name']

class studentInfoAdmin(admin.ModelAdmin):
    list_display = ['id','student_id','student_name','student_birth','belong_class']

# Register your models here.
admin.site.register(classInfo,classInfoAdmin)
admin.site.register(studentInfo,studentInfoAdmin)
</code></pre>
<h5 id="视图">视图</h5>
<p>后台管理页面做好了，接下来就要做公共访问的页面了。当我们刚刚在浏览器中输入 <a href="http://127.0.0.1:8000/admin/">http://127.0.0.1:8000/admin/</a> 之后，浏览器显示出了后台管理的登录页面，那有没有同学想过这个服务器是怎么给我们找到这个页面并返回呢？/admin/是我们想要请求的页面，服务器在收到这个请求之后，就一定对应着一个处理动作，这个处理动作就是帮我们产生页面内容并返回回来，这个过程是由<strong>视图</strong>来做的。</p>
<p>对于django的设计框架MVT，用户在URL中请求的是视图，视图接收请求后进行处理，并将处理的结果返回给请求者。</p>
<p>使用视图时需要进行两步操作：</p>
<pre><code>* 1.定义视图函数
* 2.配置URLconf
</code></pre>
<p>1.定义视图</p>
<p>视图就是一个Python函数，被定义在views.py中。</p>
<p>视图的必须有一个参数，一般叫request，视图必须返回HttpResponse对象，HttpResponse中的参数内容会显示在浏览器的页面上。</p>
<p>打开studentToClass/views.py文件，定义视图index如下</p>
<pre><code>from django.http import HttpResponse

def index(request):
    return HttpResponse(&quot;index&quot;)
</code></pre>
<p>2.配置URLconf</p>
<h5 id="查找视图的过程">查找视图的过程</h5>
<p>请求者在浏览器地址栏中输入url，请求到网站后，获取url信息，然后与编写好的URLconf逐条匹配，如果匹配成功则调用对应的视图函数，如果所有的URLconf都没有匹配成功，则返回404错误。</p>
<p>一条URLconf包括url规则、视图两部分：</p>
<ul>
<li>url规则使用正则表达式定义。</li>
<li>视图就是在views.py中定义的视图函数。</li>
</ul>
<p>需要两步完成URLconf配置：</p>
<ul>
<li>1.在应用中定义URLconf</li>
<li>2.包含到项目的URLconf中</li>
</ul>
<p>在booktest/应用下创建urls.py文件，定义代码如下：</p>
<pre><code>from django.conf.urls import url
from studentToClass import views
urlpatterns = [
    url(r'^$', views.index),
]
</code></pre>
<p>包含到项目中：打开test1/urls.py文件，为urlpatterns列表增加项如下：</p>
<pre><code>url(r'^', include('studentToClass.urls')),
</code></pre>
<p>test1/urls.py文件完整代码如下：</p>
<pre><code>from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r'^admin/', include(admin.site.urls)),
    url(r'^', include('studentToClass.urls')),
]
</code></pre>
<h5 id="请求访问">请求访问</h5>
<p>视图和URLconf都定义好了，接下来在浏览器地址栏中输入网址：</p>
<pre><code>http://127.0.0.1:8000/
</code></pre>
<p>网页显示效果如下图，视图被成功执行了。</p>
<h4 id="模板">模板</h4>
<h5 id="问题">问题</h5>
<p><strong>如何向请求者返回一个漂亮的页面呢？</strong></p>
<p>肯定需要用到html、css，如果想要更炫的效果还要加入js，问题来了，这么一堆字段串全都写到视图中，作为HttpResponse()的参数吗？这样定义就太麻烦了吧，因为定义字符串是不会出任何效果和错误的，如果有一个专门定义前端页面的地方就好了。</p>
<p>解决问题的技术来了：<strong>模板</strong>。</p>
<p>在Django中，将前端的内容定义在模板中，然后再把模板交给视图调用，各种漂亮、炫酷的效果就出现了。</p>
<p>创建模板</p>
<p>为应用booktest下的视图index创建模板index.html，目录结构如下图：</p>
<figure data-type="image" tabindex="4"><img src="https://childlike2333.github.io/post-images/1586142403955.png" alt="" loading="lazy"></figure>
<p>设置查找模板的路径：打开settings.py文件，设置TEMPLATES的DIRS值</p>
<pre><code>'DIRS': [os.path.join(BASE_DIR, 'templates')],
</code></pre>
<h5 id="定义模板">定义模板</h5>
<p>打开templtes/booktest/index.html文件，定义代码如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;班级列表&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;{{title}}&lt;/h1&gt;
{%for i in list%}
{{i}}&lt;br&gt;
{%endfor%}
&lt;/body&gt;
&lt;/html&gt; 
</code></pre>
<p>在模板中输出变量语法如下，变量可能是从视图中传递过来的，也可能是在模板中定义的。</p>
<pre><code>{{变量名}}
</code></pre>
<p>在模板中编写代码段语法如下：</p>
<pre><code>{%代码段%}
</code></pre>
<h5 id="视图调用模板">视图调用模板</h5>
<p>调用模板分为三步骤：</p>
<ul>
<li>
<p>1.找到模板</p>
</li>
<li>
<p>2.定义上下文</p>
</li>
<li>
<p>3.渲染模板</p>
<p>打开浏览器刷新页面，显示效果如下图：</p>
</li>
</ul>
<h5 id="视图调用模板简写">视图调用模板简写</h5>
<p>视图调用模板都要执行以上三部分，于是Django提供了一个函数render封装了以上代码。 方法render包含3个参数：</p>
<ul>
<li>第一个参数为request对象</li>
<li>第二个参数为模板文件路径</li>
<li>第三个参数为字典，表示向模板中传递的上下文数据</li>
</ul>
<p>打开booktst/views.py文件，调用render的代码如下：</p>
<pre><code class="language-python">from django.shortcuts import render

# Create your views here.

from django.shortcuts import render

def index(request):
    context = {'title':'班级列表','list':[1,2,3]}
    return render(request,'index.html',context)
</code></pre>
<h4 id="完成">完成</h4>
<p>index.html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;班级列表&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;{{title}}&lt;/h1&gt;
{%for class in classList%}
&lt;!--{{class.class.id}} {{class.class_id}}: {{class.class_name}}&lt;br&gt; --&gt;
{{class.class_id}}: &lt;a href=&quot;/{{class.id}}/&quot;&gt;{{class.class_name}}&lt;/a&gt;&lt;br&gt;
{%endfor%}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>detail.html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;{{title}}&lt;/h1&gt;
{%for student in studentList%}
{{student.student_id}},{{student.student_name}},{{student.student_birth}}&lt;br&gt;
{%endfor%}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h5 id="viewspy">views.py</h5>
<pre><code class="language-python">from django.shortcuts import render

# Create your views here.

from django.shortcuts import render

from studentToClass.models import classInfo,studentInfo


def index(request):


    # 班级列表
    classList = classInfo.objects.all()
    context = {'title': '班级列表', 'classList':classList}

    return render(request,'index.html',context)

def detail(request,cid):

    studentList = studentInfo.objects.filter(id=cid)

    return render(request,'detail.html',{'studentList':studentList})
</code></pre>
<h5 id="urlspy">urls.py</h5>
<pre><code class="language-python">from django.conf.urls import url

from studentToClass import views

urlpatterns = [
    url(r'^$',views.index),
    url(r'^(\d+)/$',views.detail)
]
</code></pre>
<h3 id="模型">模型</h3>
<h5 id="复习">复习</h5>
<ul>
<li>定义模型类</li>
<li>迁移</li>
<li>生成迁移</li>
</ul>
<h5 id="定义模型类">定义模型类</h5>
<ul>
<li>
<p>模型类被定义在&quot;应用/models.py&quot;文件中，此例中为&quot;studentToClass/models.py&quot;文件。</p>
</li>
<li>
<p>模型类必须继承自Model类，位于包django.db.models中。</p>
</li>
<li>
<p>命名时不能是python的保留关键字</p>
</li>
<li>
<p>不允许使用连续的下划线（由于django的查询方式决定的）</p>
</li>
<li>
<p>通过字段类型的参数指定选项</p>
</li>
</ul>
<h5 id="字段类型">字段类型</h5>
<p>AutoField：自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性。</p>
<p>BooleanField：布尔字段，值为True或False。</p>
<p>NullBooleanField：支持Null、True、False三种值。</p>
<p>CharField(max_length=字符长度)：字符串。</p>
<ul>
<li>参数max_length表示最大字符个数。</li>
</ul>
<p>TextField：大文本字段，一般超过4000个字符时使用。</p>
<p>IntegerField：整数。</p>
<p>DecimalField(max_digits=None, decimal_places=None)：十进制浮点数。</p>
<ul>
<li>参数max_digits表示总位数。</li>
<li>参数decimal_places表示小数位数。</li>
</ul>
<p>FloatField：浮点数。</p>
<p>DateField[auto_now=False, auto_now_add=False])：日期。</p>
<ul>
<li>参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于&quot;最后一次修改&quot;的时间戳，它总是使用当前日期，默认为false。</li>
<li>参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false。</li>
<li>参数auto_now_add和auto_now是相互排斥的，组合将会发生错误。</li>
</ul>
<p>TimeField：时间，参数同DateField。</p>
<p>DateTimeField：日期时间，参数同DateField。</p>
<p>FileField：上传文件字段。</p>
<p>ImageField：继承于FileField，对上传的内容进行校验，确保是有效的图片</p>
<h5 id="选项">选项</h5>
<ul>
<li>null：如果为True，表示允许为空，默认值是False。</li>
<li>blank：如果为True，则该字段允许为空白，默认值是False。</li>
<li><strong>对比：null是数据库范畴的概念，blank是表单验证范畴的</strong>。</li>
<li>db_column：字段的名称，如果未指定，则使用属性的名称。</li>
<li>db_index：若值为True, 则在表中会为此字段创建索引，默认值是False。</li>
<li>default：默认值。</li>
<li>primary_key：若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用。</li>
<li>unique：如果为True, 这个字段在表中必须有唯一值，默认值是False。</li>
</ul>
<h5 id="条件查询">条件查询</h5>
<h6 id="查询等">查询等</h6>
<p><strong>exact：表示判等。</strong></p>
<pre><code>studentList = studentInfo.objects.filter(belong_class_id__exact=1)
#studentList = studentInfo.objects.filter(belong_class=1)
</code></pre>
<p><strong>contains：是否包含。</strong></p>
<blockquote>
<p>说明：如果要包含%无需转义，直接写即可。</p>
</blockquote>
<p>例：查询书名包含'传'的图书。</p>
<pre><code>studentList = studentInfo.objects.filter(student_name__contains=&quot;小&quot;)
studentList = studentInfo.objects.filter(student_name__startswith=&quot;大&quot;)
studentList = studentInfo.objects.filter(student_name__endswith=&quot;牛&quot;)
</code></pre>
<p><strong>startswith、endswith：以指定值开头或结尾。</strong></p>
<p><strong>isnull：是否为null。</strong></p>
<p>例：查询书名不为空的图书。</p>
<pre><code>studentList = studentInfo.objects.filter(student_name__isnull=False)
</code></pre>
<h6 id="4-范围查询">4) 范围查询</h6>
<p><strong>in：是否包含在范围内。</strong></p>
<p>例：查询编号为1或3或5的图书</p>
<pre><code>studentList = studentInfo.objects.filter(student_id__in=[60101,60202])
</code></pre>
<h6 id="比较查询">比较查询</h6>
<p><strong>gt、gte、lt、lte：大于、大于等于、小于、小于等于。</strong></p>
<p>例：查询编号大于3的图书</p>
<pre><code>studentList = studentInfo.objects.filter(student_id_gt=60103)
</code></pre>
<p><strong>不等于的运算符，使用exclude()过滤器。</strong></p>
<p>例：查询编号不等于3的图书</p>
<pre><code>studentList = studentInfo.objects.exclude(student_id=60103)
</code></pre>
<p>例：查询1980年1月1日后发表的图书。</p>
<pre><code>studentInfo.objects.filter(student_birth__gt=&quot;2019-08-04&quot;)
</code></pre>
<h4 id="f对象">F对象</h4>
<p>之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？ 答：使用F对象，被定义在django.db.models中</p>
<pre><code>from django.db.models import F
studentList = studentInfo.objects.filter(student_id__gt=F('belong_class_id'))
</code></pre>
<h4 id="q对象">Q对象</h4>
<p>多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。</p>
<pre><code>studentList = studentInfo.objects.filter(student_id__gt=60103, belong_class_id=1)
</code></pre>
<p>如果需要实现逻辑或or的查询，需要使用Q()对象结合|运算符，Q对象被义在django.db.models中。</p>
<p>语法如下：</p>
<pre><code>Q(属性名__运算符=值)
</code></pre>
<p>例：查询阅读量大于20的图书，改写为Q对象如下。</p>
<pre><code>from django.db.models import Q
...
studentList = studentInfo.objects.filter(Q(student_id__gt=60103))
</code></pre>
<p>Q对象可以使用&amp;、|连接，&amp;表示逻辑与，|表示逻辑或。</p>
<p>例：班级为2或者学号大于103</p>
<pre><code>studentList = studentInfo.objects.filter(Q(student_id__gt=60103)|Q(belong_class_id=2))
</code></pre>
<p>Q对象前可以使用~操作符，表示非not。</p>
<p>例：查询编号不等于3的图书。</p>
<pre><code>studentList = studentInfo.objects.filter(~Q(belong_class_id=2))
</code></pre>
<h4 id="聚合函数">聚合函数</h4>
<p>使用aggregate()过滤器调用聚合函数。聚合函数包括：Avg，Count，Max，Min，Sum，被定义在django.db.models中。</p>
<p>例：查询图书的总阅读量。</p>
<pre><code>from django.db.models import Sum
...
studentList = studentInfo.objects.aggregate(Sum('student_id'))
</code></pre>
<p>注意aggregate的返回值是一个字典类型，格式如下：</p>
<pre><code>  {'聚合类小写__属性名':值}
  如:{'student_id__sum': 360813}
</code></pre>
<p>使用count时一般不使用aggregate()过滤器。</p>
<p>例：查询图书总数。</p>
<pre><code>studentList = studentInfo.objects.count()
</code></pre>
<p>注意count函数的返回值是一个数字。</p>
<p>查询集表示从数据库中获取的对象集合，在管理器上调用某些过滤器方法会返回查询集，查询集可以含有零个、一个或多个过滤器。过滤器基于所给的参数限制查询的结果，从Sql的角度，查询集和select语句等价，过滤器像where和limit子句。</p>
<p><strong>返回查询集的过滤器如下</strong>：</p>
<ul>
<li>all()：返回所有数据。</li>
<li>filter()：返回满足条件的数据。</li>
<li>exclude()：返回满足条件之外的数据，相当于sql语句中where部分的not关键字。</li>
<li>order_by()：对结果进行排序。</li>
</ul>
<p><strong>返回单个值的过滤器如下</strong>：</p>
<ul>
<li>get()：返回单个满足条件的对象
<ul>
<li>如果未找到会引发&quot;模型类.DoesNotExist&quot;异常。</li>
<li>如果多条被返回，会引发&quot;模型类.MultipleObjectsReturned&quot;异常。</li>
</ul>
</li>
<li>count()：返回当前查询结果的总条数。</li>
<li>aggregate()：聚合，返回一个字典。</li>
</ul>
<p><strong>判断某一个查询集中是否有数据</strong>：</p>
<ul>
<li>exists()：判断查询集中是否有数据，如果有则返回True，没有则返回False。</li>
</ul>
<h4 id="两大特性">两大特性</h4>
<ul>
<li>惰性执行：创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用。</li>
<li>缓存：使用同一个查询集，第一次使用时会发生数据库的查询，然后把结果缓存下来，再次使用这个查询集时会使用缓存的数据。</li>
</ul>
<h4 id="限制查询集">限制查询集</h4>
<p>可以对查询集进行取下标或切片操作，等同于sql中的limit和offset子句。</p>
<blockquote>
<p>注意：不支持负数索引。</p>
</blockquote>
<p>对查询集进行切片后返回一个新的查询集，不会立即执行查询。</p>
<p>如果获取一个对象，直接使用[0]，等同于[0:1].get()，但是如果没有数据，[0]引发IndexError异常，[0:1].get()如果没有数据引发DoesNotExist异常。</p>
<p>示例：获取第1、2项，运行查看。</p>
<pre><code>list=BookInfo.objects.all()[0:2]
</code></pre>
<h3 id="视图-2">视图</h3>
<h4 id="urlconf">URLconf</h4>
<p>用户通过在浏览器的地址栏中输入网址请求网站，对于Django开发的网站，由哪一个视图进行处理请求，是由url匹配找到的。</p>
<p>配置</p>
<p>1）在SMS/settings.py中通过ROOT_URLCONF指定url配置，默认已经有此配置。</p>
<figure data-type="image" tabindex="5"><img src="https://childlike2333.github.io/post-images/1586142445324.png" alt="" loading="lazy"></figure>
<p>2）打开SMS/urls.py可以看到默认配置。</p>
<figure data-type="image" tabindex="6"><img src="https://childlike2333.github.io/post-images/1586142462682.png" alt="" loading="lazy"></figure>
<h5 id="注意点">注意点</h5>
<ul>
<li>
<p>在SMS/urls.py中进行包含配置，在各自应用中创建具体配置。</p>
</li>
<li>
<p>定义urlpatterns列表，存储url()对象，这个名称是固定的。</p>
<blockquote>
<p>urlpatterns中的每个正则表达式在第一次访问它们时被编译，这使得运行很快。</p>
</blockquote>
</li>
</ul>
<h5 id="语法">语法</h5>
<p>url()对象，被定义在django.conf.urls包中，有两种语法结构：</p>
<p><strong>语法一</strong>：包含，一般在自定义应用中创建一个urls.py来定义url。</p>
<p>这种语法用于SMS/urls.py中，目的是将应用的urls配置到应用内部，数据更清晰并且易于维护。</p>
<pre><code>url(正则,include('应用.urls'))
</code></pre>
<p>1）如示例在SMS/urls.py文件，包含booktest中的urls。</p>
<pre><code>url(r'^',include('studentToClass.urls')),
</code></pre>
<ol>
<li>如示例在SMS目录下创建urls.py文件。</li>
</ol>
<p><strong>语法二</strong>：定义，指定URL和视图函数的对应关系。</p>
<p>在应用内部创建urls.py文件，指定请求地址与视图的对应关系。</p>
<pre><code>url(正则,'视图函数名称')
</code></pre>
<p>1）如示例在studentToClass/urls.py中创建首页的url，代码如下</p>
<pre><code>from django.conf.urls import url
from booktest import views
urlpatterns=[
    url(r'^$',views.index),
]
</code></pre>
<p>2）如示例在booktest/views.py中创建视图index</p>
<pre><code>from django.shortcuts import render
from django.http import HttpResponse

def index(request):
  return HttpResponse(&quot;视图函数index&quot;)
</code></pre>
<h5 id="获取值">获取值</h5>
<p>请求的url被看做是一个普通的python字符串，进行匹配时不包括域名、get或post参数。 如请求地址如下：</p>
<pre><code>http://127.0.0.1:8000/arg1
</code></pre>
<p>1）去除掉域名和参数部分，并将最前面的/去除后，只剩下如下部分与正则匹配。</p>
<pre><code>arg1/
</code></pre>
<p>2）打开booktest/urls.py文件，定义与这个地址匹配的url如下：</p>
<pre><code>url(r'^arg(\d+)/$',views.get_arg)
</code></pre>
<p>3）在booktest/views.py中创建视图show_arg。</p>
<pre><code>def get_arg(request,arg):

    return HttpResponse('arg%s'%arg)
</code></pre>
<p>4）启动服务器，输入上面的网址，浏览器中效果如下图。</p>
<figure data-type="image" tabindex="7"><img src="https://childlike2333.github.io/post-images/1586142479024.png" alt="" loading="lazy"></figure>
<p>可以在匹配过程中从url中捕获参数，每个捕获的参数都作为一个普通的python字符串传递给视图。</p>
<p>二</p>
<p>通过request获取</p>
<p><a href="http://127.0.0.1:8000/arg99/?name=5">http://127.0.0.1:8000/arg99/?name=5</a></p>
<pre><code>def get_arg(request,arg):

    name = request.GET.get('name')

    return HttpResponse('arg%s,%s'%(arg,name))
</code></pre>
<h4 id="错误视图">错误视图</h4>
<p>视图就是python中的函数，视图一般被定义在&quot;应用/views.py&quot;文件中，此例中为&quot;booktest/views.py&quot;文件。视图必须返回一个HttpResponse对象或子对象作为响应。响应可以是一张网页的HTML内容，一个重定向，一个404错误等。</p>
<p>视图的第一个参数必须为HttpRequest实例，还可能包含下参数如：</p>
<ul>
<li>通过正则表达式组获得的关键字参数。</li>
<li>通过正则表达式组获取的位置参数。</li>
</ul>
<h5 id="内置错误视图">内置错误视图</h5>
<p>Django内置处理HTTP错误的视图，主要错误及视图包括：</p>
<ul>
<li>404错误：page not found视图</li>
<li>500错误：server error视图</li>
</ul>
<p>如果想看到错误视图而不是调试信息，需要修改test3/setting.py文件的DEBUG项。</p>
<pre><code>DEBUG = False
ALLOWED_HOSTS = ['*', ]
</code></pre>
<h5 id="404错误及视图">404错误及视图</h5>
<p>将请求地址进行url匹配后，没有找到匹配的正则表达式，则调用404视图，这个视图会调用404.html的模板进行渲染。视图传递变量request_path给模板，表示导致错误的URL。</p>
<p>1）在templates中创建404.html。</p>
<p>2）定义代码如下：</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
找不到了
&lt;hr/&gt;
{{request_path}}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>3）在浏览器中输入如下网址：</p>
<pre><code>http://127.0.0.1:8000/test/
</code></pre>
<p>4）运行效果如下图：</p>
<h5 id="500错误及视图">500错误及视图</h5>
<p>在视图中代码运行报错会发生500错误，调用内置错误视图，使用templates/500.html模板渲染。</p>
<p>视图处理过程如下图：</p>
<h4 id="httpreqeust对象">HttpReqeust对象</h4>
<p>服务器接收到http协议的请求后，会根据报文创建HttpRequest对象，这个对象不需要我们创建，直接使用服务器构造好的对象就可以。<strong>视图的第一个参数必须是HttpRequest对象</strong>，在django.http模块中定义了HttpRequest对象的API。</p>
<h5 id="属性">属性</h5>
<blockquote>
<p>下面除非特别说明，属性都是只读的。</p>
</blockquote>
<ul>
<li>path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。</li>
<li>method：一个字符串，表示请求使用的HTTP方法，常用值包括：'GET'、'POST'。
<ul>
<li>在浏览器中给出地址发出请求采用get方式，如超链接。</li>
<li>在浏览器中点击表单的提交按钮发起请求，如果表单的method设置为post则为post请求。</li>
</ul>
</li>
<li>encoding：一个字符串，表示提交的数据的编码方式。
<ul>
<li>如果为None则表示使用浏览器的默认设置，一般为utf-8。</li>
<li>这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。</li>
</ul>
</li>
<li>GET：QueryDict类型对象，类似于字典，包含get请求方式的所有参数。</li>
<li>POST：QueryDict类型对象，类似于字典，包含post请求方式的所有参数。</li>
<li>FILES：一个类似于字典的对象，包含所有的上传文件。</li>
<li>COOKIES：一个标准的Python字典，包含所有的cookie，键和值都为字符串。</li>
<li>session：一个既可读又可写的类似于字典的对象，表示当前的会话，只有当Django 启用会话的支持时才可用，详细内容见&quot;状态保持&quot;。</li>
<li>运行服务器，在浏览器中浏览首页，可以在浏览器“开发者工具”中看到请求信息如下图：</li>
</ul>
<h5 id="示例">示例</h5>
<p>接下来演示属性path、method、encoding，对于GET、POST、FILES、COOKIES、session后面会有详细讲解。</p>
<h5 id="path-encoding">path、encoding</h5>
<p>1）打开booktest/views.py文件，代码如下：</p>
<pre><code>print ('%s,%s'%(request.path,request.encoding))
</code></pre>
<h5 id="method">method</h5>
<p>1）打开booktest/views.py文件，编写视图method_show，代码如下：</p>
<pre><code>return HttpResponse(request.method)
</code></pre>
<p>3）修改templates/booktest/下创建index.html文件，添加代码如下：</p>
<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
...
...
2.request对象的method属性：&lt;br/&gt;
&lt;a href='/arg22/'&gt;get方式&lt;/a&gt;&lt;br/&gt;
&lt;form method=&quot;post&quot; action=&quot;/arg22/&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;post方式&quot;&gt;
&lt;/form&gt;
&lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4）打开浏览器，输入如下网址：</p>
<pre><code>http://127.0.0.1:8000/
</code></pre>
<p>5）浏览效果如下图：</p>
<p>6）点击链接，转到method_show，浏览效果如下图:</p>
<ol>
<li>回到method_test页面，点击按钮，转到method_post，浏览效果如下图，报错了。</li>
</ol>
<p>8）打开test3/settings.py文件，将MIDDLEWARE_CLASSES项的csrf注释。</p>
<p>9）回到浏览器中刷新，浏览效果如下图，点击“继续”按钮。</p>
<p>10）最终浏览效果如下图：</p>
<p>QueryDict对象</p>
<ul>
<li>定义在django.http.QueryDict</li>
<li>HttpRequest对象的属性GET、POST都是QueryDict类型的对象</li>
<li>与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况</li>
<li>方法get()：根据键获取值</li>
<li>如果一个键同时拥有多个值将获取最后一个值</li>
<li>如果键不存在则返回None值，可以设置默认值进行后续处理</li>
</ul>
<pre><code>dict.get('键',默认值)
可简写为
dict['键']
</code></pre>
<ul>
<li>方法getlist()：根据键获取值，值以列表返回，可以获取指定键的所有值</li>
<li>如果键不存在则返回空列表[]，可以设置默认值进行后续处理</li>
</ul>
<pre><code>dict.getlist('键',默认值)
</code></pre>
<h5 id="getandpost属性">GetandPost属性</h5>
<h5 id="get属性">GET属性</h5>
<p>请求格式：在请求地址结尾使用?，之后以&quot;键=值&quot;的格式拼接，多个键值对之间以&amp;连接。</p>
<p>例：网址如下</p>
<pre><code>http://127.0.0.1/?a=10&amp;b=20&amp;c=python
</code></pre>
<p>其中的请求参数为：</p>
<pre><code>a=10&amp;b=20&amp;c=python
</code></pre>
<ul>
<li>分析请求参数，键为'a'、'b'、'c'，值为'10'、'20'、'python'。</li>
<li>在Django中可以使用HttpRequest对象的GET属性获得get方方式请求的参数。</li>
<li>GET属性是一个QueryDict类型的对象，键和值都是字符串类型。</li>
<li>键是开发人员在编写代码时确定下来的。</li>
<li>值是根据数据生成的。</li>
</ul>
<h5 id="post属性">Post属性</h5>
<pre><code class="language-python">get方式:&lt;br/&gt;
&lt;a href=&quot;/arg66/?username=1&amp;passwd=2&quot;&gt;get方式提交数据&lt;/a&gt;&lt;br/&gt;
post方式:&lt;br/&gt;
&lt;form method=&quot;post&quot; action=&quot;/arg/&quot;&gt;
    账号：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;
    密码：&lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt;&lt;br/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code>username = request.POST.get('username')
passwd = request.POST.get('passwd')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[05——前端基础]]></title>
        <id>https://childlike2333.github.io/post/05-qian-duan-ji-chu/</id>
        <link href="https://childlike2333.github.io/post/05-qian-duan-ji-chu/">
        </link>
        <updated>2020-04-06T02:28:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端开发概述">前端开发概述</h2>
<h4 id="什么是前端开发">什么是前端开发</h4>
<blockquote>
<p>前端开发也叫做web前端开发，它指的是基于web的互联网产品的页面(也可叫界面)开发及功能开发。</p>
</blockquote>
<h4 id="什么是互联网产品">什么是互联网产品</h4>
<blockquote>
<p>互联网产品就是指网站为满足用户需求而创建的用于运营的功能及服务，百度搜索、淘宝、QQ、微博、网易邮箱等都是互联网产品。</p>
</blockquote>
<h4 id="前端需要的技术">前端需要的技术</h4>
<p>UI设计师设计出来的页面样式效果图</p>
<p>把效果图布局成页面： HTML语言和CSS语言</p>
<p>页面功能的开发：javascript和一些框架</p>
<h2 id="html语言">HTML语言</h2>
<h3 id="html概述">HTML概述</h3>
<h4 id="什么是html语言">什么是HTML语言</h4>
<blockquote>
<p>HTML是 HyperText Mark-up Language 的首字母简写，意思是超文本标记语言，超文本指的是超链接，标记指的是标签，是一种用来制作网页的语言，这种语言由一个个的标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm，一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。</p>
</blockquote>
<h4 id="html文档类型">HTML文档类型</h4>
<p>xhtml 1.0 是html5之前常用的一个版本，不过目前html5已经基本取代了xhtml 1.0，在html5中增加了标签元素以及元素属性。</p>
<h4 id="第一个html">第一个HTML</h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;  &lt;!-- 文档声明--&gt;
&lt;html lang=&quot;en&quot;&gt;  &lt;!-- 定义html文档的整体,en定义网页的语言为英文，定义为中文是zh-CN,没啥关系，一般作为分析统计用--&gt;
&lt;head&gt; &lt;!-- head标签负责对网页进行一些设置以及定义标题，设置包括定义网页的编码格式，外链css样式文件和javascript文件等--&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt; &lt;!-- 标题的内容会显示在标题栏--&gt;
&lt;/head&gt;
&lt;body&gt; &lt;!--内编写网页上显示的内容 --&gt;
注释： &lt;!-- 这是一段注释 --&gt;
什么是前端
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="html标签">HTML标签</h3>
<h4 id="标题标签">标题标签</h4>
<p>通过 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;,标签可以在网页上定义6种级别的标题。6种级别的标题表示文档的6级目录层级关系，比如说： &lt;h1&gt;用作主标题，其后是 &lt;h2&gt;，再其次是&lt;h3&gt;，以此类推。搜索引擎会使用标题将网页的结构和内容编制索引，所以网页上使用标题是很重要的。</p>
<h4 id="段落标签">段落标签</h4>
<p>段落标签:  &lt;p&gt;标签定义一个文本段落，一个段落含有默认的上下间距，段落之间会用这种默认间距隔开</p>
<h4 id="换行标签">换行标签</h4>
<p>代码中成段的文字，直接在代码中回车换行，在渲染成网页时候不认这种换行，如果真想换行，可以在代码的段落中插入&lt;br&gt; 或者&lt;br |/&gt;来强制换行</p>
<h4 id="空格">空格</h4>
<p>代码中成段的文字，如果文字间想空多个空格，在代码中空多个空格，在渲染成网页时只会显示一个空格，如果想显示多个空格，可以使用空格的字符实体,代码如下：&amp;nbsp;</p>
<p>在网页上显示 “&lt;” 和 “&gt;” 会误认为是标签，想在网页上显示“&lt;”和“&gt;”可以使用它们的字符实体，比如： 3 &amp;lt; 5   &amp;gt</p>
<h4 id="html块标签">html块标签</h4>
<p>块元素 &lt;div&gt;： 表示一块内容，没有具体的语义，但是非常重要</p>
<p>行内元素&lt;span&gt; : 表示一行中的一小段内容，没有具体的语义</p>
<h4 id="图像标签">图像标签</h4>
<p>&lt;img&gt;标签可以在网页上插入一张图片，它是独立使用的标签，它的常用属性有：</p>
<ul>
<li>src属性 定义图片的引用地址</li>
<li>alt属性 定义图片加载失败时显示的文字，搜索引擎会使用这个文字收录图片、盲人读屏软件会读取这个文字让盲人识别图片，所以此属性非常重要。</li>
</ul>
<pre><code>&lt;img src=&quot;images/pic.jpg&quot; alt=&quot;产品图片&quot; /&gt;
</code></pre>
<h4 id="绝对路径和相对路径">绝对路径和相对路径</h4>
<p>像网页上插入图片这种外部文件，需要定义文件的引用地址，引用外部文件还包括引用外部样式表，javascript等等，引用地址分为绝对地址和相对地址。</p>
<ul>
<li>绝对地址：相对于磁盘的位置去定位文件的地址</li>
<li>相对地址：相对于引用文件本身去定位被引用的文件地址</li>
</ul>
<p>绝对地址在整体文件迁移时会因为磁盘和顶层目录的改变而找不到文件，相对路径就没有这个问题。相对路径的定义技巧：</p>
<ul>
<li>“ ./ ” 表示当前文件所在目录下，比如：“./pic.jpg” 表示当前目录下的pic.jpg的图片，这个使用时可以省略。</li>
<li>“ ../ ” 表示当前文件所在目录下的上一级目录，比如：“../images/pic.jpg” 表示当前目录下的上一级目录下的images文件夹中的pic.jpg的图片</li>
</ul>
<h4 id="链接标签">链接标签</h4>
<p>&lt;a&gt;标签可以在网页上定义一个链接地址，它的常用属性有：</p>
<ul>
<li>href属性 定义跳转的地址</li>
<li>title属性 定义鼠标悬停时弹出的提示文字框</li>
<li>target属性 定义链接窗口打开的位置
<ul>
<li>target=&quot;_self&quot; 缺省值，新页面替换原来的页面，在原来位置打开</li>
<li>target=&quot;_blank&quot; 新页面会在新开的一个浏览器窗口打开</li>
</ul>
</li>
</ul>
<pre><code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; &lt;!--  # 表示链接到页面顶部   --&gt;
&lt;a href=&quot;http://www.itcast.cn/&quot; title=&quot;跳转的传智播客网站&quot;&gt;传智播客&lt;/a&gt;
&lt;a href=&quot;2.html&quot; target=&quot;_blank&quot;&gt;测试页面2&lt;/a&gt;
</code></pre>
<h4 id="有编号列表">有编号列表</h4>
<h5 id="有序列表">有序列表</h5>
<p>在网页上定义一个有编号的内容列表可以用<ol>、<li>配合使用来实现，代码如下：</p>
<pre><code>&lt;ol&gt;
    &lt;li&gt;列表文字一&lt;/li&gt;
    &lt;li&gt;列表文字二&lt;/li&gt;
    &lt;li&gt;列表文字三&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<h5 id="无序列表">无序列表</h5>
<p>在网页上定义一个无编号的内容列表可以用<ul>、<li>配合使用来实现，代码如下：</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻标题一&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻标题二&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻标题三&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h4 id="表格">表格</h4>
<p>&lt;table&gt;标签：声明一个表格，它的常用属性如下：</p>
<ul>
<li>border属性 定义表格的边框，设置值是数值</li>
<li>cellpadding属性 定义单元格内容与边框的距离，设置值是数值</li>
<li>cellspacing属性 定义单元格与单元格之间的距离，设置值是数值</li>
<li>align属性 设置整体表格相对于浏览器窗口的水平对齐方式,设置值有：left | center | right</li>
</ul>
<p>2、&lt;tr&gt;标签：定义表格中的一行</p>
<p>3、&lt;td&gt;和&lt;th&gt;标签：定义一行中的一个单元格，td代表普通单元格，th表示表头单元格，它们的常用属性如下：</p>
<ul>
<li>align 设置单元格中内容的水平对齐方式,设置值有：left | center | right</li>
<li>valign 设置单元格中内容的垂直对齐方式 top | middle | bottom</li>
<li>colspan 设置单元格水平合并，设置值是数值</li>
<li>rowspan 设置单元格垂直合并，设置值是数值</li>
</ul>
<h3 id="表单">表单</h3>
<p>表单用于搜集不同类型的用户输入，表单由不同类型的标签组成，相关标签及属性用法如下：</p>
<p>1、&lt;form&gt;标签 定义整体的表单区域</p>
<ul>
<li>action属性 定义表单数据提交地址</li>
<li>method属性 定义表单提交的方式，一般有“get”方式和“post”方式</li>
</ul>
<p>2、&lt;label&gt;标签 为表单元素定义文字标注</p>
<p>3、&lt;input&gt;标签 定义通用的表单元素</p>
<ul>
<li>type属性
<ul>
<li>type=&quot;text&quot; 定义单行文本输入框</li>
<li>type=&quot;password&quot; 定义密码输入框</li>
<li>type=&quot;radio&quot; 定义单选框</li>
<li>type=&quot;checkbox&quot; 定义复选框</li>
<li>type=&quot;file&quot; 定义上传文件</li>
<li>type=&quot;submit&quot; 定义提交按钮</li>
<li>type=&quot;reset&quot; 定义重置按钮</li>
<li>type=&quot;button&quot; 定义一个普通按钮</li>
<li>type=&quot;image&quot; 定义图片作为提交按钮，用src属性定义图片地址</li>
<li>type=&quot;hidden&quot; 定义一个隐藏的表单域，用来存储值</li>
</ul>
</li>
<li>value属性 定义表单元素的值</li>
<li>name属性 定义表单元素的名称，此名称是提交数据时的键名</li>
</ul>
<p>4、&lt;textarea&gt;标签 定义多行文本输入框</p>
<p>5、&lt;select&gt;标签 定义下拉表单元素</p>
<p>6、&lt;option&gt;标签 与&lt;select&gt;标签配合，定义下拉表单元素中的选项</p>
<p><strong>注册表单实例：</strong></p>
<pre><code class="language-html">&lt;form action=&quot;http://www...&quot; method=&quot;get&quot;&gt;
&lt;p&gt;
&lt;label&gt;姓名：&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;label&gt;性别：&lt;/label&gt;
&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; /&gt; 男
&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; /&gt; 女
&lt;/p&gt;
&lt;p&gt;
&lt;label&gt;爱好：&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;sing&quot; /&gt; 唱歌
&lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;run&quot; /&gt; 跑步
&lt;input type=&quot;checkbox&quot; name=&quot;like&quot; value=&quot;swiming&quot; /&gt; 游泳
&lt;/p&gt;
&lt;p&gt;
&lt;label&gt;照片：&lt;/label&gt;
&lt;input type=&quot;file&quot; name=&quot;person_pic&quot;&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;label&gt;个人描述：&lt;/label&gt;
&lt;textarea name=&quot;about&quot;&gt;&lt;/textarea&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;label&gt;籍贯：&lt;/label&gt;
&lt;select name=&quot;site&quot;&gt;
    &lt;option value=&quot;0&quot;&gt;北京&lt;/option&gt;
    &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt;
    &lt;option value=&quot;2&quot;&gt;广州&lt;/option&gt;
    &lt;option value=&quot;3&quot;&gt;深圳&lt;/option&gt;
&lt;/select&gt;
&lt;/p&gt;
&lt;p&gt;
&lt;input type=&quot;submit&quot; name=&quot;&quot; value=&quot;提交&quot;&gt;
&lt;!-- input类型为submit定义提交按钮  
     还可以用图片控件代替submit按钮提交，一般会导致提交两次，不建议使用。如：
     &lt;input type=&quot;image&quot; src=&quot;xxx.gif&quot;&gt;
--&gt;
&lt;input type=&quot;reset&quot; name=&quot;&quot; value=&quot;重置&quot;&gt;
&lt;/p&gt;
&lt;/form&gt;
</code></pre>
<h2 id="css">CSS</h2>
<h3 id="css概述">CSS概述</h3>
<p>为了让网页元素的样式更加丰富，也为了让网页的内容和样式能拆分开，CSS由此思想而诞生，CSS是 Cascading Style Sheets<br>
的首字母缩写，意思是层叠样式表。有了CSS，html中大部分表现样式的标签就废弃不用了，html只负责文档的结构和内容，表现形式完全交给CSS，html文档变得更加简洁。</p>
<h3 id="css基本语法及页面引用">CSS基本语法及页面引用</h3>
<h4 id="基本语法">基本语法</h4>
<p>css的定义方法是：</p>
<blockquote>
<p>选择器 { 属性:值; 属性:值; 属性:值;}</p>
</blockquote>
<p>选择器是将样式和页面元素关联起来的名称，属性是希望设置的样式属性每个属性有一个或多个值。代码示例：</p>
<pre><code>/*
    css注释 ctrl+shift+&quot;/&quot;
*/


div{ 
    width:100px; 
    height:100px; 
    color:red 
}
</code></pre>
<h4 id="css页面引入方法">css页面引入方法</h4>
<p>1、外联式：通过link标签，链接到外部样式表到页面中。</p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/main.css&quot;&gt;
</code></pre>
<p>2、嵌入式：通过style标签，在网页上创建嵌入的样式表。</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
    div{ width:100px; height:100px; color:red }
    ......
&lt;/style&gt;
</code></pre>
<p>3、内联式：通过标签的style属性，在标签上直接写样式。</p>
<pre><code>&lt;div style=&quot;width:100px; height:100px; color:red &quot;&gt;......&lt;/div&gt;
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;content-Type&quot; charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;style&gt;
        #d2 {color: green}
    &lt;/style&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;d1&quot; style=&quot;color: red&quot;&gt;我是一个div标签&lt;/div&gt;
&lt;div id=&quot;d2&quot;&gt;我是一个div&lt;/div&gt;
&lt;div id=&quot;d3&quot;&gt;我是一个div&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-css">/*
这是 测试CSS引入的一个文件
*/

#d3 {color: blue}
</code></pre>
<h3 id="css文本设置">CSS文本设置</h3>
<p>常用的应用文本的css样式：</p>
<ul>
<li>
<p>color 设置文字的颜色，如： color:red;</p>
</li>
<li>
<p>font-size 设置文字的大小，如：font-size:12px;</p>
</li>
<li>
<p>font-family 设置文字的字体，如：font-family:'微软雅黑';</p>
</li>
<li>
<p>font-style 设置字体是否倾斜，如：font-style:'normal';  设置不倾斜，font-style:'italic';设置文字倾斜</p>
</li>
<li>
<p>font-weight 设置文字是否加粗，如：font-weight:bold; 设置加粗 font-weight:normal 设置不加粗</p>
</li>
<li>
<p>line-height 设置文字的行高，设置行高相当于在每行文字的上下同时加间距， 如：line-height:24px;   <img src="https://childlike2333.github.io/post-images/1586141951791.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>font 同时设置文字的几个属性，写的顺序有兼容问题，建议按照如下顺序写： font：是否加粗 字号/行高 字体；如： font:normal 12px/36px '微软雅黑';</p>
</li>
<li>
<p>text-decoration 设置文字的下划线，如：text-decoration:none; 将文字下划线去掉</p>
</li>
<li>
<p>text-indent 设置文字首行缩进，如：text-indent:24px; 设置文字首行缩进24px   <img src="https://childlike2333.github.io/post-images/1586142046989.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>text-align 设置文字水平对齐方式，如text-align:center 设置文字水平居中</p>
</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        #t1 {color: green;
            font-size:13px;
            font-family: '微软雅黑';
            font-style:italic;
            font-weight:bold;
            line-height: 24px;
            text-decoration:underline;
            text-align: center;
        }

    &lt;/style&gt;

    &lt;div id=&quot;t1&quot;&gt;为了让网页元素的样式更加丰富，也为了让网页的内容和样式能拆分开，CSS由此思想而诞生，CSS是 Cascading Style Sheets
的首字母缩写，意思是层叠样式表。有了CSS，html中大部分表现样式的标签就废弃不用了，html只负责文档的结构和内容，表现形式完全交给CSS，html文档变得更加简洁。&lt;/div&gt;

&lt;/head&gt;
&lt;body&gt;


&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="css颜色表示法">css颜色表示法</h3>
<p>css颜色值主要有三种表示方法：</p>
<p>1、颜色名表示，比如：red 红色，gold 金色</p>
<p>2、rgb表示，比如：rgb(255,0,0)表示红色,</p>
<p><em>RGB</em>色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，<em>RGB</em>即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。</p>
<p>3、16进制数值表示，比如：#ff0000 表示红色，这种可以简写成 #f00，而16进制数值表示则就是将rgb的数值转换成3个16进制数来进行表示</p>
<h3 id="css选择器">css选择器</h3>
<p>常用的选择器有如下几种：</p>
<h5 id="1-标签选择器">1、标签选择器</h5>
<p>标签选择器，此种选择器影响范围大，建议尽量应用在层级选择器中。<br>
举例：</p>
<pre><code>*{margin:0;padding:0}
div{color:red}   


&lt;div&gt;....&lt;/div&gt;   &lt;!-- 对应以上两条样式 --&gt;
&lt;div class=&quot;box&quot;&gt;....&lt;/div&gt;   &lt;!-- 对应以上两条样式 --&gt;
</code></pre>
<h5 id="2-id选择器">2、id选择器</h5>
<p>通过id名来选择元素，元素的id名称不能重复，所以一个样式设置项只能对应于页面上一个元素，不能复用，id名一般给程序使用，所以不推荐使用id作为选择器。<br>
举例：</p>
<pre><code>#box{color:red} 

&lt;div id=&quot;box&quot;&gt;....&lt;/div&gt;   &lt;!-- 对应以上一条样式，其它元素不允许应用此样式 --&gt;
</code></pre>
<h5 id="3-类选择器">3、类选择器</h5>
<p>通过类名来选择元素，一个类可应用于多个元素，一个元素上也可以使用多个类，应用灵活，可复用，是css中应用最多的一种选择器。<br>
举例：</p>
<pre><code>.red{color:red}
.big{font-size:20px}
.mt10{margin-top:10px} 

&lt;div class=&quot;red&quot;&gt;....&lt;/div&gt;
&lt;h1 class=&quot;red big mt10&quot;&gt;....&lt;/h1&gt;
&lt;p class=&quot;red mt10&quot;&gt;....&lt;/p&gt;
</code></pre>
<h5 id="4-层级选择器">4、层级选择器</h5>
<p>主要应用在选择父元素下的子元素，或者子元素下面的子元素，可与标签元素结合使用，减少命名，同时也可以通过层级，防止命名冲突。<br>
举例：</p>
<pre><code>.box span{color:red}
.box .red{color:pink}
.red{color:red}

&lt;div class=&quot;box&quot;&gt;
    &lt;span&gt;....&lt;/span&gt;
    &lt;a href=&quot;#&quot; class=&quot;red&quot;&gt;....&lt;/a&gt;
&lt;/div&gt;

&lt;h3 class=&quot;red&quot;&gt;....&lt;/h3&gt;
</code></pre>
<h5 id="5-组选择器">5、组选择器</h5>
<p>多个选择器，如果有同样的样式设置，可以使用组选择器。<br>
举例：</p>
<pre><code>.box1,.box2,.box3{width:100px;height:100px}
.box1{background:red}
.box2{background:pink}
.box2{background:gold}

&lt;div class=&quot;box1&quot;&gt;....&lt;/div&gt;
&lt;div class=&quot;box2&quot;&gt;....&lt;/div&gt;
&lt;div class=&quot;box3&quot;&gt;....&lt;/div&gt;
</code></pre>
<h5 id="6-伪类及伪元素选择器">6、伪类及伪元素选择器</h5>
<p>常用的伪类选择器有hover，表示鼠标悬浮在元素上时的状态，伪元素选择器有before和after,它们可以通过样式在元素中插入内容。</p>
<pre><code>.box1:hover{color:red}
.box2:before{content:'行首文字';}
.box3:after{content:'行尾文字';}


&lt;div class=&quot;box1&quot;&gt;....&lt;/div&gt;
&lt;div class=&quot;box2&quot;&gt;....&lt;/div&gt;
&lt;div class=&quot;box3&quot;&gt;....&lt;/div&gt;
</code></pre>
<p>Css的内容还有非常的多，包括模型，浮动，定位等等，但是这部分不是我们学习的重点，我们只需要学会什么是CSS，并且能够试着修改它的部分属性即可，我们已经有非常多优秀的前端开源框架，去做这部分的属性，提供给我们最编辑的使用方法，比如 layui、 elementUI等等，他们都提供了最简便的使用方式，让我们能够构建复杂的界面，layui更是面向后端服务器端开发者的框架。</p>
<h2 id="javascript">JavaScript</h2>
<p>JavaScript是运行在浏览器端的脚步语言，JavaScript主要解决的是前端与用户交互的问题，包括使用交互与数据交互。 JavaScript是浏览器解释执行的，前端脚本语言还有JScript（微软，IE独有），ActionScript( Adobe公司，需要插件)等。</p>
<p><strong>前端三大块</strong><br>
1、HTML：页面结构<br>
2、CSS：页面表现：元素大小、颜色、位置、隐藏或显示、部分动画效果<br>
3、JavaScript：页面行为：部分动画效果、页面与用户的交互、页面功能</p>
<h3 id="javascript嵌入页面的方式">JavaScript嵌入页面的方式</h3>
<p>1、行间事件（主要用于事件）</p>
<pre><code>&lt;input type=&quot;button&quot; name=&quot;&quot; onclick=&quot;alert('ok！');&quot;&gt;
</code></pre>
<p>2、页面script标签嵌入</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;        
    alert('ok！');
&lt;/script&gt;
</code></pre>
<p>3、外部引入</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/index.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; name=&quot;&quot; onclick=&quot;alert('ok！');&quot;&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    alert('ok！');
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-js">alert('ok！');
</code></pre>
<h3 id="变量">变量</h3>
<p>JavaScript 是一种弱类型语言，javascript的变量类型由它的值来决定。 定义变量需要用关键字 'var'</p>
<pre><code> var iNum = 123;
 var sTr = 'asd';

 //同时定义多个变量可以用&quot;,&quot;隔开，公用一个‘var’关键字

 var iNum = 45,sTr='qwe',sCount='68';
</code></pre>
<p><strong>变量类型</strong></p>
<p>5种基本数据类型：<br>
1、number 数字类型<br>
2、string 字符串类型<br>
3、boolean 布尔类型 true 或 false<br>
4、undefined  undefined类型，变量声明未初始化，它的值就是undefined<br>
5、null null类型，表示空对象，如果定义的变量将来准备保存对象，可以将变量初始化为null,在页面上获取不到对象，返回的值就是null</p>
<p>1种复合类型：<br>
object</p>
<p><strong>javascript语句与注释</strong></p>
<p>1、一条javascript语句应该以“;”结尾</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    
var iNum = 123;
var sTr = 'abc123';
function fnAlert(){
    alert(sTr);
};
fnAlert();
&lt;/script&gt;
</code></pre>
<p>2、javascript注释</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    

// 单行注释
var iNum = 123;
/*  
    多行注释
    1、...
    2、...
*/
var sTr = 'abc123';
&lt;/script&gt;
</code></pre>
<p><strong>变量、函数、属性、函数参数命名规范</strong></p>
<p>1、区分大小写<br>
2、第一个字符必须是字母、下划线（_）或者美元符号（$）<br>
3、其他字符可以是字母、下划线、美元符或数字</p>
<h3 id="获取元素方法一">获取元素方法一</h3>
<p>可以使用内置对象document上的getElementById方法来获取页面上设置了id属性的元素，获取到的是一个html对象，然后将它赋值给一个变量，比如：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var oDiv = document.getElementById('div1');
&lt;/script&gt;
....
&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;
</code></pre>
<p>上面的语句，如果把javascript写在元素的上面，就会出错，因为页面上从上往下加载执行的，javascript去页面上获取元素div1的时候，元素div1还没有加载，解决方法有两种：</p>
<p>第一种方法：将javascript放到页面最下边</p>
<pre><code>....
&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;
....

&lt;script type=&quot;text/javascript&quot;&gt;
    var oDiv = document.getElementById('div1');
&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>第二种方法：将javascript语句放到window.onload触发的函数里面,获取元素的语句会在页面加载完后才执行，就不会出错了。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    window.onload = function(){
        var oDiv = document.getElementById('div1');
    }
&lt;/script&gt;

....

&lt;div id=&quot;div1&quot;&gt;这是一个div元素&lt;/div&gt;
</code></pre>
<h3 id="操作元素属性">操作元素属性</h3>
<p>获取的页面元素，就可以对页面元素的属性进行操作，属性的操作包括属性的读和写。</p>
<p><strong>操作属性的方法</strong><br>
1、“.” 操作<br>
2、“[ ]”操作</p>
<p><strong>属性写法</strong></p>
<p>1、html的属性和js里面属性写法一样<br>
2、“class” 属性写成 “className”<br>
3、“style” 属性里面的属性，有横杠的改成驼峰式，比如：“font-size”，改成”style.fontSize”</p>
<p>通过“.”操作属性：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;input1&quot; value=&quot;这是一个输入框&quot;&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

    window.onload = function(){
        var oInput = document.getElementById('input1');
        oInput.value = &quot;233333&quot;;
        oInput.style.color = 'blue';
        oInput.style.fontSize = '24px';
    }

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>innerHTML</strong><br>
innerHTML可以读取或者写入标签包裹的内容</p>
<p>对象.innerText 设置标签里面的文本</p>
<p>对象.innerHTML设置可以为标签设置html内容</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;input1&quot; value=&quot;这是一个输入框&quot;&gt;
&lt;a id=&quot;aHref&quot; href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

    window.onload = function(){
        var oInput = document.getElementById('input1');
        oInput.value = &quot;233333&quot;;
        oInput.style.color = 'blue';
        oInput.style.fontSize = '24px';

        var aHref = document.getElementById('aHref')
        //aHref.innerText = '腾讯'
        aHref.innerHTML = '&lt;p&gt;这是一个测试&lt;p/&gt;';

    }

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<h3 id="函数">函数</h3>
<p>函数就是重复执行的代码片。</p>
<p><strong>函数定义与执行</strong></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    // 函数定义
    function fnAlert(){
        alert('hello!');
    }
    // 函数执行
    fnAlert();
&lt;/script&gt;
</code></pre>
<p><strong>变量与函数预解析</strong><br>
JavaScript解析过程分为两个阶段，先是编译阶段，然后执行阶段，在编译阶段会将function定义的函数提前，并且将var定义的变量声明提前，将它赋值为undefined。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    
    fnAlert();       // 弹出 hello！
    alert(iNum);  // 弹出 undefined
    function fnAlert(){
        alert('hello!');
    }
    var iNum = 123;
&lt;/script&gt;
</code></pre>
<p><strong>提取行间事件</strong><br>
在html行间调用的事件可以提取到javascript中调用，从而做到结构与行为分离。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;input1&quot; value=&quot;这是一个输入框&quot;&gt;
&lt;input type=&quot;button&quot; value=&quot;弹出输入的内容&quot; onclick=&quot;fnAlert()&quot;&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

        function fnAlert(){
            var oInput = document.getElementById('input1');
            inputValue = oInput.value;
            alert(inputValue)
        }

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>匿名函数</strong></p>
<p>定义的函数可以不给名称，这个叫做匿名函数，可以将匿名函数直接赋值给元素绑定的事件来完成匿名函数的调用。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;input1&quot; value=&quot;这是一个输入框&quot;&gt;
&lt;input type=&quot;button&quot; value=&quot;弹出输入的内容&quot; id=&quot;button1&quot;&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;

    var but1 = document.getElementById('button1');
    but1.onclick = function () {
        var oInput = document.getElementById('input1');
        inputValue = oInput.value;
        alert(inputValue)
    }

&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>函数传参</strong></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    function fnAlert(a){
        alert(a);
    }
    fnAlert(12345);
&lt;/script&gt;
</code></pre>
<p><strong>函数'return'关键字</strong><br>
函数中'return'关键字的作用：<br>
1、返回函数执行的结果<br>
2、结束函数的运行<br>
3、阻止默认行为</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function fnAdd(iNum01,iNum02){
    var iRs = iNum01 + iNum02;
    return iRs;
    alert('here!');
}

var iCount = fnAdd(3,4);
alert(iCount);  //弹出7
&lt;/script&gt;
</code></pre>
<h3 id="条件语句">条件语句</h3>
<p>通过条件来控制程序的走向，就需要用到条件语句。</p>
<p><strong>运算符</strong><br>
1、算术运算符： +(加)、 -(减)、 *(乘)、 /(除)、 %(求余)<br>
2、赋值运算符：=、 +=、 -=、 *=、 /=、 %=<br>
3、条件运算符：<mark>、</mark>=、&gt;、&gt;=、&lt;、&lt;=、!=、&amp;&amp;(而且)、||(或者)、!(否)</p>
<p><strong>if else</strong></p>
<pre><code>var iNum01 = 3;
var iNum02 = 5;
var sTr;
if(iNum01&gt;iNum02){
    sTr = '大于';
}
else
{
    sTr = '小于';
}
alert(sTr);
</code></pre>
<p><strong>理解练习</strong><br>
制作单个按钮点击切换元素的显示和隐藏效果</p>
<p><strong>多重if else语句</strong></p>
<pre><code>var iNow = 1;
if(iNow==1)
{
    ... ;
}
else if(iNow==2)
{
    ... ;
}
else
{
    ... ;
}
</code></pre>
<p><strong>switch语句</strong><br>
多重if else语句可以换成性能更高的switch语句</p>
<pre><code>var iNow = 1;

switch (iNow){
    case 1:
        ...;
        break;
    case 2:
        ...;
        break;    
    default:
        ...;
}
</code></pre>
<h3 id="数组及操作方法">数组及操作方法</h3>
<p>数组就是一组数据的集合，javascript中，数组里面的数据可以是不同类型的。</p>
<p><strong>定义数组的方法</strong></p>
<pre><code>//对象的实例创建
var aList = new Array(1,2,3);

//直接量创建
var aList2 = [1,2,3,'asd'];
</code></pre>
<p><strong>操作数组中数据的方法</strong><br>
1、获取数组的长度：aList.length;</p>
<pre><code>var aList = [1,2,3,4];
alert(aList.length); // 弹出4
</code></pre>
<p>2、用下标操作数组的某个数据：aList[0];</p>
<pre><code>var aList = [1,2,3,4];
alert(aList[0]); // 弹出1
</code></pre>
<p>3、join()  将数组成员通过一个分隔符合并成字符串</p>
<pre><code>var aList = [1,2,3,4];
alert(aList.join('-')); // 弹出 1-2-3-4
</code></pre>
<p>4、push() 和 pop() 从数组最后增加成员或删除成员</p>
<pre><code>var aList = [1,2,3,4];
aList.push(5);
alert(aList); //弹出1,2,3,4,5
aList.pop();
alert(aList); // 弹出1,2,3,4
</code></pre>
<p>5、unshift()和 shift()  从数组前面增加成员或删除成员</p>
<pre><code>var aList = [1,2,3,4];
aList.unshift(5);
alert(aList); //弹出5,1,2,3,4
aList.shift();
alert(aList); // 弹出1,2,3,4
</code></pre>
<p>6、reverse() 将数组反转</p>
<pre><code>var aList = [1,2,3,4];
aList.reverse();
alert(aList);  // 弹出4,3,2,1
</code></pre>
<p>7、indexOf() 返回数组中元素第一次出现的索引值</p>
<pre><code>var aList = [1,2,3,4,1,3,4];
alert(aList.indexOf(1));
</code></pre>
<p>8、splice() 在数组中增加或删除成员</p>
<pre><code>var aList = [1,2,3,4];
aList.splice(2,1,7,8,9); //从第2个元素开始，删除1个元素，然后在此位置增加'7,8,9'三个元素
alert(aList); //弹出 1,2,7,8,9,4
</code></pre>
<p><strong>多维数组</strong><br>
多维数组指的是数组的成员也是数组的数组。</p>
<pre><code>var aList = [[1,2,3],['a','b','c']];

alert(aList[0][1]); //弹出2;
</code></pre>
<p>批量操作数组中的数据，需要用到循环语句</p>
<h3 id="循环语句">循环语句</h3>
<p>程序中进行有规律的重复性操作，需要用到循环语句。</p>
<p><strong>for循环</strong></p>
<pre><code>for(var i=0;i&lt;len;i++)
{
    ......
}
</code></pre>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var aList = [1,2,3,4];
    for(var i=0;i&lt;aList.length;i++){
        alert(aList[i])
    }
&lt;/script&gt; 
</code></pre>
<p><strong>while循环</strong></p>
<pre><code>var i=0;

while(i&lt;8){
    ......
    i+;
}
</code></pre>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var aList = [1,2,3,4];
    var i = 0;
    while(i&lt;aList.length){
        alert(aList[i])
        i = i + 1;
    }
&lt;/script&gt;
</code></pre>
<p><strong>数组去重</strong></p>
<pre><code>var aList = [1,2,3,4,4,3,2,1,2,3,4,5,6,5,5,3,3,4,2,1];

var aList2 = [];

for(var i=0;i&lt;aList.length;i++)
{
    if(aList.indexOf(aList[i])==i)
    {
        aList2.push(aList[i]);
    }
}

alert(aList2);
</code></pre>
<h3 id="字符串处理方法">字符串处理方法</h3>
<p>1、字符串合并操作：“ + ”</p>
<pre><code>var iNum01 = 12;
var iNum02 = 24;
var sNum03 = '12';
var sTr = 'abc';
alert(iNum01+iNum02);  //弹出36
alert(iNum01+sNum03);  //弹出1212 数字和字符串相加等同于字符串相加
alert(sNum03+sTr);     // 弹出12abc
</code></pre>
<p>2、parseInt() 将数字字符串转化为整数</p>
<pre><code>var sNum01 = '12';
var sNum02 = '24';
var sNum03 = '12.32';
alert(sNum01+sNum02);  //弹出1224
alert(parseInt(sNum01)+parseInt(sNum02))  //弹出36
alert(sNum03)   //弹出数字12 将字符串小数转化为数字整数
</code></pre>
<p>3、parseFloat() 将数字字符串转化为小数</p>
<pre><code>var sNum03 = '12.32'
alert(parseFloat(sNum03));  //弹出 12.32 将字符串小数转化为数字小数
</code></pre>
<p>4、split() 把一个字符串分隔成字符串组成的数组</p>
<pre><code>var sTr = '2017-4-22';
var aRr = sTr.split(&quot;-&quot;);
var aRr2= sTr.split(&quot;&quot;);

alert(aRr);  //弹出['2017','4','2']
alert(aRr2);  //弹出['2','0','1','7','-','4','-','2','2']
</code></pre>
<p>5、charAt() 获取字符串中的某一个字符</p>
<pre><code>var sId = &quot;#div1&quot;;
var sTr = sId.charAt(0);
alert(sTr); //弹出 #
</code></pre>
<p>6、indexOf() 查找字符串是否含有某字符</p>
<pre><code>var sTr = &quot;abcdefgh&quot;;
var iNum = sTr.indexOf(&quot;c&quot;);
alert(iNum); //弹出2
</code></pre>
<p>7、substring() 截取字符串  用法： substring(start,end)（不包括end）</p>
<pre><code>var sTr = &quot;abcdefghijkl&quot;;
var sTr2 = sTr.substring(3,5);
var sTr3 = sTr.substring(1);

alert(sTr2); //弹出 de
alert(sTr3); //弹出 bcdefghijkl
</code></pre>
<p>8、toUpperCase() 字符串转大写</p>
<pre><code>var sTr = &quot;abcdef&quot;;
var sTr2 = sTr.toUpperCase();
alert(sTr2); //弹出ABCDEF
</code></pre>
<p>9、toLowerCase() 字符串转小写</p>
<pre><code>var sTr = &quot;ABCDEF&quot;;
var sTr2 = sTr.toLowerCase();
alert(sTr2); //弹出abcdef
</code></pre>
<p><strong>字符串反转</strong></p>
<pre><code>var str = 'asdfj12jlsdkf098';
var str2 = str.split('').reverse().join('');

alert(str2);
</code></pre>
<h3 id="调试程序的方法">调试程序的方法</h3>
<p>1、alert</p>
<p>2、console.log</p>
<p>3、document.title</p>
<h2 id="jquery">Jquery</h2>
<h3 id="jquery介绍">jquery介绍</h3>
<p>jQuery是目前使用最广泛的javascript函数库。据统计，全世界排名前100万的网站，有46%使用jQuery，远远超过其他库。微软公司甚至把jQuery作为他们的官方库。</p>
<p>jQuery的版本分为1.x系列和2.x、3.x系列，1.x系列兼容低版本的浏览器，2.x、3.x系列放弃支持低版本浏览器，目前使用最多的是1.x系列的。</p>
<p>jquery是一个函数库，一个js文件，页面用script标签引入这个js文件就可以使用。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.2.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>jquery的口号和愿望 Write Less, Do More（写得少，做得多）</p>
<p>1、<a href="http://jquery.com/">http://jquery.com/</a> 官方网站<br>
2、<a href="https://code.jquery.com/">https://code.jquery.com/</a>   版本下载</p>
<h3 id="jquery加载">jquery加载</h3>
<p>将获取元素的语句写到页面头部，会因为元素还没有加载而出错，jquery提供了ready方法解决这个问题，它的速度比原生的 window.onload 更快。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;

$(document).ready(function(){

     ......

});

&lt;/script&gt;
</code></pre>
<p>可以简写为：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;

$(function(){

     ......

});

&lt;/script&gt;
</code></pre>
<h3 id="jquery选择器">jquery选择器</h3>
<p><strong>jquery用法思想一</strong><br>
选择某个网页元素，然后对它进行某种操作</p>
<p><strong>jquery选择器</strong><br>
jquery选择器可以快速地选择元素，选择规则和css样式相同，使用length属性判断是否选择成功。</p>
<pre><code>$('#myId') //选择id为myId的网页元素
$('.myClass') // 选择class为myClass的元素
$('li') //选择所有的li元素
$('#ul1 li span') //选择id为为ul1元素下的所有li下的span元素
$('input[name=first]') // 选择name属性等于first的input元素
</code></pre>
<p><strong>对选择集进行过滤</strong></p>
<pre><code>$('div').has('p'); // 选择包含p元素的div元素
$('div').not('.myClass'); //选择class不等于myClass的div元素
$('div').filter('.myClass'); //选择class等于myClass的div元素
$('div').eq(5); //选择第6个div元素
</code></pre>
<p><strong>选择集转移</strong></p>
<pre><code>$('div').prev(); //选择div元素前面紧挨的同辈元素
$('div').prevAll(); //选择div元素之前所有的同辈元素
$('div').next(); //选择div元素后面紧挨的同辈元素
$('div').nextAll(); //选择div元素后面所有的同辈元素
$('div').parent(); //选择div的父元素
$('div').children(); //选择div的所有子元素
$('div').siblings(); //选择div的同级元素
$('div').find('.myClass'); //选择div内的class等于myClass的元素
</code></pre>
<p><strong>判断是否选择到了元素</strong><br>
jquery有容错机制，即使没有找到元素，也不会出错，可以用length属性来判断是否找到了元素,length等于0，就是没选择到元素，length大于0，就是选择到了元素。</p>
<pre><code>var $div1 = $('#div1');
var $div2 = $('#div2');
alert($div1.length); // 弹出1
alert($div2.length); // 弹出0
......
&lt;div id=&quot;div1&quot;&gt;这是一个div&lt;/div&gt;
</code></pre>
<h3 id="jquery样式操作">jquery样式操作</h3>
<p><strong>jquery用法思想二</strong><br>
同一个函数完成取值和赋值</p>
<p><strong>操作行间样式</strong></p>
<pre><code>// 获取div的样式
$(&quot;div&quot;).css(&quot;width&quot;);
$(&quot;div&quot;).css(&quot;color&quot;);

//设置div的样式
$(&quot;div&quot;).css(&quot;width&quot;,&quot;30px&quot;);
$(&quot;div&quot;).css(&quot;height&quot;,&quot;30px&quot;);
$(&quot;div&quot;).css({fontSize:&quot;30px&quot;,color:&quot;red&quot;});
</code></pre>
<p><strong>特别注意</strong><br>
选择器获取的多个元素，获取信息获取的是第一个，比如：$(&quot;div&quot;).css(&quot;width&quot;)，获取的是第一个div的width。</p>
<p><strong>操作样式类名</strong></p>
<pre><code>$(&quot;#div1&quot;).addClass(&quot;divClass2&quot;) //为id为div1的对象追加样式divClass2
$(&quot;#div1&quot;).removeClass(&quot;divClass&quot;)  //移除id为div1的对象的class名为divClass的样式
$(&quot;#div1&quot;).removeClass(&quot;divClass divClass2&quot;) //移除多个样式
$(&quot;#div1&quot;).toggleClass(&quot;anotherClass&quot;) //重复切换anotherClass样式
</code></pre>
<h3 id="绑定click事件">绑定click事件</h3>
<p>给元素绑定click事件，可以用如下方法：</p>
<pre><code>$('#btn1').click(function(){

    // 内部的this指的是原生对象

    // 使用jquery对象用 $(this)

})
</code></pre>
<p><strong>获取元素的索引值</strong><br>
有时候需要获得匹配元素相对于其同胞元素的索引位置，此时可以用index()方法获取</p>
<pre><code>var $li = $('.list li').eq(1);
alert($li.index()); // 弹出1
......
&lt;ul class=&quot;list&quot;&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
    &lt;li&gt;6&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<h3 id="jquery特殊效果">jquery特殊效果</h3>
<pre><code>fadeIn() 淡入

    $btn.click(function(){

        $('#div1').fadeIn(1000,'swing',function(){
            alert('done!');
        });

    });

fadeOut() 淡出
fadeToggle() 切换淡入淡出
hide() 隐藏元素
show() 显示元素
toggle() 切换元素的可见状态
slideDown() 向下展开
slideUp() 向上卷起
slideToggle() 依次展开或卷起某个元素
</code></pre>
<h3 id="尺寸相关-滚动事件">尺寸相关、滚动事件</h3>
<p>1、获取和设置元素的尺寸</p>
<pre><code>width()、height()    获取元素width和height  
innerWidth()、innerHeight()  包括padding的width和height  
outerWidth()、outerHeight()  包括padding和border的width和height  
outerWidth(true)、outerHeight(true)   包括padding和border以及margin的width和height
</code></pre>
<p>2、获取元素相对页面的绝对位置</p>
<pre><code>offset()
</code></pre>
<p><strong>课堂练习</strong></p>
<p>加入购物车动画</p>
<p>3、获取浏览器可视区宽度高度</p>
<pre><code>$(window).width();
$(window).height();
</code></pre>
<p>4、获取页面文档的宽度高度</p>
<pre><code>$(document).width();
$(document).height();
</code></pre>
<p>5、获取页面滚动距离</p>
<pre><code>$(document).scrollTop();  
$(document).scrollLeft();
</code></pre>
<p>6、页面滚动事件</p>
<pre><code>$(window).scroll(function(){  
    ......  
})
</code></pre>
<h3 id="jquery属性操作">jquery属性操作</h3>
<p>1、html() 取出或设置html内容</p>
<pre><code>// 取出html内容

var $htm = $('#div1').html();

// 设置html内容

$('#div1').html('&lt;span&gt;添加文字&lt;/span&gt;');
</code></pre>
<p>2、prop() 取出或设置某个属性的值</p>
<pre><code>// 取出图片的地址

var $src = $('#img1').prop('src');

// 设置图片的地址和alt属性

$('#img1').prop({src: &quot;test.jpg&quot;, alt: &quot;Test Image&quot; });
</code></pre>
<h4 id="json">json</h4>
<p>json是 JavaScript Object Notation 的首字母缩写，单词的意思是javascript对象表示法，这里说的json指的是类似于javascript对象的一种数据格式，目前这种数据格式比较流行，逐渐替换掉了传统的xml数据格式。</p>
<p>javascript自定义对象：</p>
<pre><code>var oMan = {
    name:'tom',
    age:16,
    talk:function(s){
        alert('我会说'+s);
    }
}
</code></pre>
<p>json格式的数据：</p>
<pre><code>{
    &quot;name&quot;:&quot;tom&quot;,
    &quot;age&quot;:18
}
</code></pre>
<p>与json对象不同的是，json数据格式的属性名称和字符串值需要用双引号引起来，用单引号或者不用引号会导致读取数据错误。</p>
<p>json的另外一个数据格式是数组，和javascript中的数组字面量相同。</p>
<pre><code>[&quot;tom&quot;,18,&quot;programmer&quot;]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[03——PyQt基础]]></title>
        <id>https://childlike2333.github.io/post/03-pyqt-ji-chu/</id>
        <link href="https://childlike2333.github.io/post/03-pyqt-ji-chu/">
        </link>
        <updated>2020-04-06T02:26:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="pyqt框架介绍">PyQt框架介绍</h3>
<h4 id="pyqt框架简介">PyQt框架简介</h4>
<p>在目前的软件设计过程中，图形用户界面GUI的设计相当重要，美观、易用的用户界面能够在很大程度上提高软件的使用量。在介绍PyQt框架之前，我们先来了解什么是 GUI 用户图形界面。</p>
<blockquote>
<p>图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。<br>
与早期计算机使用的命令行界面相比，图形界面对于用户来说在视觉上更易于接受。然而这界面若要通过在显示屏的特定位置，以”各种美观而不单调的视觉消息“提示用户”状态的改变“，势必得比简单的消息呈现花上更多的计算能力。</p>
</blockquote>
<p>PyQt最初是作为一门脚本语言开发的，并不具备GUI功能，但由于其本身具有良好的可拓展性，能够不断地通过C/C++模块进行功能性拓展，因此目前已经有相当多的GUI控件集可以在Python中使用。</p>
<p>常用的GUI控件有PyQt、Tkinter、wxPython、Kivy等，其中PyQt是Qt为Python专门提供的GUI拓展。</p>
<blockquote>
<p>PyQt是一个创建GUI应用程序的工具包。它是Python编程语言和Qt库的成功融合。Qt库是目前最强大的库之一。PyQt是由Phil Thompson 开发。<br>
PyQt实现了一个Python模块集。它有超过300类，将近6000个函数和方法。它是一个多平台的工具包，可以运行在所有主要操作系统上，包括UNIX，Windows和Mac。 PyQt采用双许可证，开发人员可以选择GPL和商业许可。在此之前，GPL的版本只能用在Unix上，从PyQt的版本4开始，GPL许可证可用于所有支持的平台。</p>
</blockquote>
<h4 id="pyqt的特点">PyQt的特点</h4>
<ul>
<li>基于高性能的Qt的GUI控件集</li>
<li>能够跨平台运行在Windows、Linux、Mac OS等系统上</li>
<li>对Qt库的完全封装</li>
<li>可以使用Qt成熟的IED（Qt Designer）进行图形界面设计，并自动生成可执行的Python代码</li>
<li>提供了一整套种类繁多，功能齐备的窗口控件。</li>
</ul>
<h4 id="在windows下搭建pyqt5环境">在Windows下搭建PyQt5环境</h4>
<pre><code class="language-python">pip install PyQt5
pip install PyQt5-tools
</code></pre>
<h3 id="基本窗口控件和第一个gui程序">基本窗口控件和第一个GUI程序</h3>
<h4 id="常用窗口类型介绍">常用窗口类型介绍</h4>
<p>QWidget 基础窗口控件是所有用户界面对象的基类，所有的窗口和控件都是直接或者间接继承自QWidget类。窗口指：没有嵌入到其他控件中的控件称为窗口，一般窗口都会有边框、标题栏、工具栏、关闭按钮、最小化按钮等。控件指：按钮、复选框、文本框、表格、进度条等这些组成程序的基本元素。</p>
<p>QMainWindow 主窗口，包含菜单栏、工具栏、状态栏、标题栏等，是最常见的窗口形式，也可以说是GUI程序的主窗口</p>
<p>QDialog 是对话框窗口的基类，主要用于执行短期任务，与用户进行互动，这种窗口没有菜单栏、工具栏、状态栏等。</p>
<ul>
<li>如果是主窗口就使用QMainWindow类</li>
<li>如果是对话框，就是用QDialog类</li>
<li>如果不确定用途，有可能作为顶层窗口，也有可能嵌入到其他窗口中的，那么就使用QWidget类</li>
</ul>
<h4 id="第一个helloworld">第一个helloworld</h4>
<p>面向过程的方式</p>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import QApplication, QMainWindow
#这里引入了PyQt5.QtWidgets模块，这个模块包含了基本的组件。

if __name__ == '__main__':

    #每个PyQt5应用都必须创建一个应用对象。sys.argv是一组命令行参数的列表。
    app = QApplication(sys.argv)

    #QWidge控件是一个用户界面的基本控件，它提供了基本的应用构造器。默认情况下，构造器是没有父级的，没有父级的构造器被称为窗口（window）
    mywindow = QMainWindow()

    #resize()方法能改变控件的大小，这里的意思是窗口宽250px，高150px。
    mywindow.resize(500, 500)

    #我们给这个窗口添加了一个标题，标题在标题栏展示
    mywindow.setWindowTitle('第一个hello程序')

    #move()是修改控件位置的的方法。它把控件放置到屏幕坐标的(300, 300)的位置。注：屏幕坐标系的原点是屏幕的左上角。
    mywindow.move(300, 300)

    #show()能让控件在桌面上显示出来。控件在内存里创建，之后才能在显示器上显示出来
    mywindow.show()

    #最后，我们进入了应用的主循环中，事件处理器这个时候开始工作。主循环从窗口上接收事件，并把事件传入到派发到应用控件里。当调用exit()方法或直接销毁主控件时，主循环就会结束。sys.exit()方法能确保主循环安全退出。外部环境能通知主控件怎么结束。
    #exec_()之所以有个下划线，是因为exec是一个Python的关键字。
    sys.exit(app.exec_())
</code></pre>
<p>面向对象的方式</p>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *


class Example(QMainWindow):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        # setGeometry()有两个作用：把窗口放到屏幕上并且设置窗口大小。参数分别代表屏幕坐标的x、y和窗口大小的宽、高。也就是说这个方法是resize()和move()的合体。
        self.setGeometry(300, 300, 300, 220)

        self.setWindowTitle('第一个hello程序')

        # 设置窗口的图标
        self.setWindowIcon(QIcon('test.png'))

        self.show()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *


class Example(QMainWindow):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        # setGeometry()有两个作用：把窗口放到屏幕上并且设置窗口大小。参数分别代表屏幕坐标的x、y和窗口大小的宽、高。也就是说这个方法是resize()和move()的合体。
        self.setGeometry(300, 300, 500, 500)

        self.setWindowTitle('第一个hello程序')

        # 设置窗口的图标
        self.setWindowIcon(QIcon('test.png'))

        # 1.创建状态栏
        self.status = self.statusBar()
        self.status.showMessage('这是提示信息', 4000)

        newAction = QAction(QIcon('test.png'), '新增', self)

        # 2.创建菜单栏
        self.menubar = self.menuBar()
        self.menubar.addAction(newAction)

        # 3.创建工具栏
        self.toolbar = self.addToolBar('New')
        self.toolbar.addAction(newAction)

        self.show()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h3 id="控件类型和布局方式">控件类型和布局方式</h3>
<p>前面我们讲述了PyQt的两种控件类型，一种为窗口控件，另一种就是基础控件，那这些控件在开发时之间的层级关系和布局的逻辑关系是怎么样的呢。</p>
<p>窗口控件： QMainWindow QWidget QDialog</p>
<p>基本控件： 标签（QLable）	文本框（QLineEdit）  多行文本框（QTextEdit）  按钮（QPushButton）。。。。</p>
<p>常用布局方式：</p>
<ul>
<li>绝对布局，按照像素位置进行绝对定位</li>
<li>盒布局，水平布局和垂直布局 （QHBoxLayout  QVBoxLayout）</li>
<li>栅格布局，把窗口分为行和列。 QGridLayout</li>
</ul>
<p>注意的是QMainWindow不能直接使用使用布局，常用的方式是在主窗口中添加一个中心控件QWidget，然后再使用布局。</p>
<h4 id="绝对布局">绝对布局</h4>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import QWidget, QLabel, QApplication

class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()


    def initUI(self):

        lbl1 = QLabel('hello',self)
        lbl1.move(15, 10)

        lbl2 = QLabel('world',self)
        lbl2.move(35, 40)

        lbl3 = QLabel('good day',self)
        lbl3.move(55, 70)

        self.setGeometry(300, 300, 250, 150)
        self.setWindowTitle('Absolute')
        self.show()


if __name__ == '__main__':

    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="盒布局">盒布局</h4>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        lbl1 = QLabel('hello')

        lbl2 = QLabel('world')

        lbl3 = QLabel('good day')
		
		# 创建盒布局
        hbox = QHBoxLayout()
        hbox.addWidget(lbl1)
        hbox.addWidget(lbl2)
        hbox.addWidget(lbl3)
        self.setLayout(hbox)

        self.setGeometry(300, 300, 250, 150)
        self.setWindowTitle('BoxLayout')
        self.show()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="栅格布局">栅格布局</h4>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        lbl1 = QLabel('hello')

        lbl2 = QLabel('world')

        lbl3 = QLabel('good day')

        lt1 = QLineEdit('hello')
        lt2 = QLineEdit('world')
        lt3 = QLineEdit('good day')

        # 创建栅格布局
        grid = QGridLayout()
        grid.addWidget(lbl1,1,1)
        grid.addWidget(lt1,1,2)
        grid.addWidget(lbl2,2,1)
        grid.addWidget(lt2,2,2)
        grid.addWidget(lbl3,3,1)
        grid.addWidget(lt3,3,2)
        self.setLayout(grid)

        self.setGeometry(500, 500, 500, 500)
        self.setWindowTitle('BoxLayout')
        self.show()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="在mainwindow中使用布局">在Mainwindow中使用布局</h4>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *


class Example(QMainWindow):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        widget = QWidget()

        lbl1 = QLabel('hello')

        lbl2 = QLabel('world')

        lbl3 = QLabel('good day')

        lt1 = QLineEdit('hello')
        lt2 = QLineEdit('world')
        lt3 = QLineEdit('good day')

        # 创建盒布局
        grid = QGridLayout()
        grid.addWidget(lbl1,1,1)
        grid.addWidget(lt1,1,2)
        grid.addWidget(lbl2,2,1)
        grid.addWidget(lt2,2,2)
        grid.addWidget(lbl3,3,1)
        grid.addWidget(lt3,3,2)
        widget.setLayout(grid)

        self.setCentralWidget(widget)
        self.setGeometry(500, 500, 500, 500)
        self.setWindowTitle('BoxLayout')
        self.show()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://childlike2333.github.io/post-images/1586141828087.png" alt="" loading="lazy"></figure>
<h3 id="基本控件详解">基本控件详解</h3>
<h4 id="qlabel-标签类">QLabel 标签类</h4>
<blockquote>
<p>QLabel对象作为一个占位符可以显示不可编辑的文本或者图片。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>setAignment()</td>
<td>按固定值方式对其文本<br />- Qt.AlignLeft  水平方向靠左对齐<br />- Qt.AlignRight 水平方向靠右对齐<br />- Qt.AlignCenter  水平方向居中对齐<br />- Qt.AlignJustify  水平方向调整间距两端对齐<br />- Qt.AlignTop  垂直方向靠上对齐<br />- Qt.AlignBottom  垂直方向靠下对齐<br />- Qt.AlignVCenter  垂直方向居中对齐<br /></td>
</tr>
<tr>
<td>setToolTip()</td>
<td>设置提示</td>
</tr>
<tr>
<td>setPixmap()</td>
<td>设置QLabel为一个图片</td>
</tr>
<tr>
<td>text()</td>
<td>获取QLabel的文本内容</td>
</tr>
<tr>
<td>setText()</td>
<td>设置QLable的文本内容</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *
from PyQt5.Qt import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        lbl1 = QLabel('hello')

        lbl2 = QLabel('world')

        lbl3 = QLabel('good day')

        #设置文本居中
        lbl1.setAlignment(Qt.AlignCenter)
        lbl1.setText('设置为 hello')

        lbl2.setToolTip('这是一个提示')
        print (lbl2.text())
        lbl3.setPixmap(QPixmap(&quot;test.png&quot;))

        # 创建盒布局
        hbox = QHBoxLayout()
        hbox.addWidget(lbl1)
        hbox.addWidget(lbl2)
        hbox.addWidget(lbl3)
        self.setLayout(hbox)

        self.setGeometry(300, 300, 250, 150)
        self.setWindowTitle('BoxLayout')
        self.show()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="qlineedit-单行文本框">QLineEdit 单行文本框</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>setAignment()</td>
<td>按固定值方式对其文本<br />- Qt.AlignLeft  水平方向靠左对齐<br />- Qt.AlignRight 水平方向靠右对齐<br />- Qt.AlignCenter  水平方向居中对齐<br />- Qt.AlignJustify  水平方向调整间距两端对齐<br />- Qt.AlignTop  垂直方向靠上对齐<br />- Qt.AlignBottom  垂直方向靠下对齐<br />- Qt.AlignVCenter  垂直方向居中对齐<br /></td>
</tr>
<tr>
<td>clear()</td>
<td>清楚文本</td>
</tr>
<tr>
<td>setMaxLength()</td>
<td>设置文本框允许输入的最大字符</td>
</tr>
<tr>
<td>text()</td>
<td>返回文本框的输入内容</td>
</tr>
<tr>
<td>setText()</td>
<td>设置文本框的输入内容</td>
</tr>
<tr>
<td>selectAll()</td>
<td>全选</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>信号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selectionChanged</td>
<td>选择改变了，这个事件就会被触发</td>
</tr>
<tr>
<td>textChanged</td>
<td>当修改文本内容时，这个事件就会被触发</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *
from PyQt5.Qt import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        #创建对象，文本框输入有默认值
        lt1 = QLineEdit('hello')

        lt2 = QLineEdit()
        lt2.setText('world')

        #获取文本框的值
        print (lt2.text())

        #设置最大长度
        self.lt3 = QLineEdit()
        self.lt3.setMaxLength(10)
        self.lt3.selectionChanged.connect(self.selectionChangedAction)
        self.lt3.textChanged.connect(self.textChangedAction)

        #设置lt2全选
        lt1.selectAll()

        #设置button
        button1 = QPushButton('clear lt3')
        button1.clicked.connect(self.lt3.clear)

        # 创建盒布局
        hbox = QVBoxLayout()
        hbox.addWidget(lt1)
        hbox.addWidget(lt2)
        hbox.addWidget(self.lt3)
        hbox.addWidget(button1)


        self.setLayout(hbox)

        self.setGeometry(300, 300, 400, 400)
        self.setWindowTitle('BoxLayout')
        self.show()

    def selectionChangedAction(self):

        print ('文本选中改变')

    def textChangedAction(self):

        print ('文本修改')



if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="qtextedit-多行文本框">QTextEdit 多行文本框</h4>
<p>多行文本框和单行文本框的用法上基本上没有差别，不多做赘述。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>setAignment()</td>
<td>按固定值方式对其文本<br />- Qt.AlignLeft  水平方向靠左对齐<br />- Qt.AlignRight 水平方向靠右对齐<br />- Qt.AlignCenter  水平方向居中对齐<br />- Qt.AlignJustify  水平方向调整间距两端对齐<br />- Qt.AlignTop  垂直方向靠上对齐<br />- Qt.AlignBottom  垂直方向靠下对齐<br />- Qt.AlignVCenter  垂直方向居中对齐<br /></td>
</tr>
<tr>
<td>clear()</td>
<td>清除文本</td>
</tr>
<tr>
<td>toPlainText()</td>
<td>返回文本框的输入内容</td>
</tr>
<tr>
<td>setText()</td>
<td>设置文本框的输入内容</td>
</tr>
<tr>
<td>selectAll()</td>
<td>全选</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>信号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>selectionChanged</td>
<td>选择改变了，这个事件就会被触发</td>
</tr>
<tr>
<td>textChanged</td>
<td>当修改文本内容时，这个事件就会被触发</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *
from PyQt5.Qt import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        #创建对象，文本框输入有默认值
        lt1 = QTextEdit('hello')

        lt2 = QTextEdit()
        lt2.setText('world')

        #获取文本框的值
        print (lt2.toPlainText())

        #设置最大长度
        self.lt3 = QTextEdit()
        self.lt3.selectionChanged.connect(self.selectionChangedAction)
        self.lt3.textChanged.connect(self.textChangedAction)

        #设置lt2全选
        lt1.selectAll()

        #设置button
        button1 = QPushButton('clear lt3')
        button1.clicked.connect(self.lt3.clear)

        # 创建盒布局
        hbox = QVBoxLayout()
        hbox.addWidget(lt1)
        hbox.addWidget(lt2)
        hbox.addWidget(self.lt3)
        hbox.addWidget(button1)


        self.setLayout(hbox)

        self.setGeometry(300, 300, 400, 400)
        self.setWindowTitle('BoxLayout')
        self.show()

    def selectionChangedAction(self):

        print ('文本选中改变')

    def textChangedAction(self):

        print ('文本修改')



if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="按钮类控件-qabstractbutton">按钮类控件 QAbstractButton</h4>
<blockquote>
<p>QAbstractButton类为抽象类，不能实例化，必须由其他的按钮类继承QAbstractButton类，来实现不同的功能和表现形式，常见的按钮QPushButton，QToolButton，QRadioButton和QCheckBox这些按钮均继承自QAbstractButton类，根据各自的使用场景通过图形显示出来</p>
</blockquote>
<h4 id="qpushbutton-按钮">QPushButton 按钮</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>setIcon</td>
<td>设置按钮上的图标</td>
</tr>
<tr>
<td>setEnabled</td>
<td>设置按钮是否可用</td>
</tr>
<tr>
<td>setText</td>
<td>设置按钮的显示文本</td>
</tr>
<tr>
<td>text</td>
<td>返回按钮的显示文本</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>事件</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>pressed</td>
<td>当鼠标指针在按钮上并按下左键时触发该事件</td>
</tr>
<tr>
<td>released</td>
<td>当鼠标左键被释放时触发该信号</td>
</tr>
<tr>
<td>clicked</td>
<td>当鼠标左键被按下然后释放时触发该信号</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">import sys
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        vlayout = QVBoxLayout()

        bt1 = QPushButton('1')
        bt2 = QPushButton('2')
        bt3 = QPushButton('3')

        #返回按钮显示的文本
        bt1.setText('按钮1')
        print (bt1.text())

        bt2.setEnabled(False)

        bt3.setIcon(QIcon('test.png'))

        vlayout.addWidget(bt1)
        vlayout.addWidget(bt2)
        vlayout.addWidget(bt3)

        bt3.pressed.connect(self.pressedAction)
        bt3.released.connect(self.releasedAction)
        bt3.clicked.connect(self.clickedAction)

        self.setLayout(vlayout)
        self.setGeometry(300, 300, 400, 400)
        self.setWindowTitle('BoxLayout')
        self.show()

    def pressedAction(self):

        print ('press')

    def releasedAction(self):

        print ('released')

    def clickedAction(self):

        print ('clicked')

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="qradiobutton-单选按钮">QRadioButton 单选按钮</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>setChecked()</td>
<td>设置按钮是否已经被选中</td>
</tr>
<tr>
<td>isChecked()</td>
<td>返回单选按钮的状态</td>
</tr>
<tr>
<td>setText()</td>
<td>设置单选按钮的文本</td>
</tr>
<tr>
<td>text()</td>
<td>返回单选按钮的显示文本</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">import sys
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        vlayout = QVBoxLayout()

        bt1 = QRadioButton('1')
        bt2 = QRadioButton('2')
        bt3 = QRadioButton('3')

        #返回按钮显示的文本
        bt1.setText('按钮1')
        print (bt1.text())
        bt1.setChecked(True)
        print (bt1.isChecked())
        bt2.setEnabled(False)

        print (bt2.isChecked())
        bt3.setIcon(QIcon('test.png'))

        vlayout.addWidget(bt1)
        vlayout.addWidget(bt2)
        vlayout.addWidget(bt3)

        bt3.pressed.connect(self.pressedAction)
        bt3.released.connect(self.releasedAction)
        bt3.clicked.connect(self.clickedAction)

        self.setLayout(vlayout)
        self.setGeometry(300, 300, 400, 400)
        self.setWindowTitle('BoxLayout')
        self.show()

    def pressedAction(self):

        print ('press')

    def releasedAction(self):

        print ('released')

    def clickedAction(self):

        print ('clicked')

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="qcheckbox-复选框">QCheckBox 复选框</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>setChecked()</td>
<td>设置复选框的状态</td>
</tr>
<tr>
<td>setText()</td>
<td>设置复选框的文本</td>
</tr>
<tr>
<td>text()</td>
<td>返回复选框的显示文本</td>
</tr>
<tr>
<td>isChecked()</td>
<td>是否被选中</td>
</tr>
<tr>
<td>setTriState()</td>
<td>设置为三态复选框</td>
</tr>
<tr>
<td>setCheckState()</td>
<td>设置为三态复选框的状态 2 1 0</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">import sys
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        vlayout = QVBoxLayout()

        bt1 = QCheckBox('1')
        bt2 = QCheckBox('2')
        bt3 = QCheckBox('3')

        bt4 = QCheckBox('4')
        bt4.setTristate()
        bt4.setCheckState(1)

        #返回按钮显示的文本
        bt1.setText('按钮1')
        print (bt1.text())
        bt1.setChecked(True)
        print (bt1.isChecked())
        bt2.setEnabled(False)

        print (bt2.isChecked())
        bt3.setIcon(QIcon('test.png'))

        vlayout.addWidget(bt1)
        vlayout.addWidget(bt2)
        vlayout.addWidget(bt3)
        vlayout.addWidget(bt4)

        bt3.pressed.connect(self.pressedAction)
        bt3.released.connect(self.releasedAction)
        bt3.clicked.connect(self.clickedAction)


        self.setLayout(vlayout)
        self.setGeometry(300, 300, 400, 400)
        self.setWindowTitle('BoxLayout')
        self.show()

    def pressedAction(self):

        print ('press')

    def releasedAction(self):

        print ('released')

    def clickedAction(self):

        print ('clicked')

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="qcombobox-下拉框">QComboBox 下拉框</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>addItem()</td>
<td>添加一个下拉选项</td>
</tr>
<tr>
<td>addItems()</td>
<td>从列表中添加下拉选项</td>
</tr>
<tr>
<td>clear()</td>
<td>删除下拉选项集合中的所有选项</td>
</tr>
<tr>
<td>count()</td>
<td>返回下拉选项集合中的数据</td>
</tr>
<tr>
<td>currentText()</td>
<td>返回选中选项的文本</td>
</tr>
<tr>
<td>itemText(i)</td>
<td>获取索引为i的item的选项文本</td>
</tr>
<tr>
<td>currentIndex()</td>
<td>返回选中项的索引</td>
</tr>
<tr>
<td>setItemText(int index,text)</td>
<td>改变序号列为index的文本</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>事件</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>activated</td>
<td>当用户选中一个下拉选项时发射该信号</td>
</tr>
</tbody>
</table>
<pre><code class="language-python">import sys
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        vlayout = QVBoxLayout()

        self.cb1 = QComboBox()

        #增加一个下拉选项
        self.cb1.addItem('1')

        #增加一个下拉列表
        list1 = ['2','3','4']
        self.cb1.addItems(list1)

        print (self.cb1.count())

        #改变序号为index的文本
        print (self.cb1.itemText(2))

        self.cb1.setItemText(3,'hello')

        self.cb1.activated.connect(self.changeIndex)

        vlayout.addWidget(self.cb1)

        self.setLayout(vlayout)
        self.setGeometry(300, 300, 100, 100)
        self.setWindowTitle('BoxLayout')
        self.show()

    def changeIndex(self):

        print (self.cb1.currentIndex())
        print (self.cb1.currentText())

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="qdialog-对话框">QDialog 对话框</h4>
<blockquote>
<p>为了更好的实现人机交互，pyqt提供了一些对话框，来进行实现和用户的临时交互任务，比如经常会提示的，你是否确定关闭的对话框，就是其中的一种</p>
</blockquote>
<p>QDialog类的子类主要有QMessageBox,QFileDialog,QColorDialog等</p>
<pre><code class="language-python">import sys
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        vlayout = QVBoxLayout()
        self.bt = QPushButton('弹出对话框')
        self.bt.clicked.connect(self.dialog)

        vlayout.addWidget(self.bt)

        self.setLayout(vlayout)
        self.setGeometry(300, 300, 100, 100)
        self.setWindowTitle('BoxLayout')
        self.show()

    def dialog(self):

        # 创建QDialog对象
        dialog = QDialog()

        # 创建按钮到新创建的dialog对象中
        btn1 = QPushButton('确定', dialog)
        btn2 = QPushButton('取消', dialog)

        # 移动按钮，设置dialog的标题
        btn1.move(50, 50)
        btn2.move(150, 50)
        dialog.setWindowTitle(&quot;Dialog&quot;)

        btn1.clicked.connect(dialog.accept)
        btn2.clicked.connect(dialog.reject)

        # 设置窗口的属性为ApplicationModal模态，用户只有关闭弹窗后，才能关闭主界面
        dialog.setWindowModality(Qt.ApplicationModal)

        if dialog.exec_():
            print ('确定')
        else:
            print ('取消')

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h4 id="qmessagebox-提示框">QMessageBox 提示框</h4>
<pre><code class="language-python">import sys
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *


class Example(QWidget):

    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):

        vlayout = QVBoxLayout()
        self.bt = QPushButton('弹出对话框')
        self.bt.clicked.connect(self.dialog)

        vlayout.addWidget(self.bt)

        self.setLayout(vlayout)
        self.setGeometry(300, 300, 100, 100)
        self.setWindowTitle('BoxLayout')
        self.show()

    def dialog(self):

        hint_msg = QMessageBox()
        hint_msg.setText('这是一个提示框')
        #hint_msg.addButton(QMessageBox.Ok)
        hint_msg.setWindowTitle(&quot;提示&quot;)
        hint_msg.exec_()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
</code></pre>
<h3 id="高级控件之表格-qtablewidget">高级控件之表格 QTableWidget</h3>
<pre><code class="language-python">import sys
from PyQt5.QtWidgets import *

class Table(QWidget):
    def __init__(self):
        super(Table, self).__init__()
        self.initUI()
    def initUI(self):
        self.setWindowTitle(&quot;QTableWidget例子&quot;)
        self.resize(400,300)
        layout=QHBoxLayout()

        #实现的效果是一样的，四行三列，所以要灵活运用函数，这里只是示范一下如何单独设置行列
        TableWidget=QTableWidget(4,3)

        # TableWidget = QTableWidget()
        # TableWidget.setRowCount(4)
        # TableWidget.setColumnCount(3)



        #设置水平方向的表头标签与垂直方向上的表头标签，注意必须在初始化行列之后进行，否则，没有效果
        TableWidget.setHorizontalHeaderLabels(['姓名','性别','体重（kg）'])
        #Todo 优化1 设置垂直方向的表头标签
        #TableWidget.setVerticalHeaderLabels(['行1', '行2', '行3', '行4'])

        #TODO 优化 2 设置水平方向表格为自适应的伸缩模式
        ##TableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        #TODO 优化3 将表格变为禁止编辑
        #TableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)

        #TODO 优化 4 设置表格整行选中
        #TableWidget.setSelectionBehavior(QAbstractItemView.SelectRows)

        #TODO 优化 5 将行与列的高度设置为所显示的内容的宽度高度匹配
        #QTableWidget.resizeColumnsToContents(TableWidget)
        #QTableWidget.resizeRowsToContents(TableWidget)

        #TODO 优化 6 表格头的显示与隐藏
        #TableWidget.verticalHeader().setVisible(False)
        #TableWidget.horizontalHeader().setVisible(False)

        #TOdo 优化7 在单元格内放置控件
        # comBox=QComboBox()
        # comBox.addItems(['男','女'])
        # comBox.addItem('未知')
        # comBox.setStyleSheet('QComboBox{margin:3px}')
        # TableWidget.setCellWidget(0,1,comBox)
        #
        # searchBtn=QPushButton('修改')
        # searchBtn.setDown(True)
        # searchBtn.setStyleSheet('QPushButton{margin:3px}')
        # TableWidget.setCellWidget(0,2,searchBtn)


        #添加数据
        newItem=QTableWidgetItem('张三')
        TableWidget.setItem(0,0,newItem)

        newItem=QTableWidgetItem('男')
        TableWidget.setItem(0,1,newItem)

        newItem=QTableWidgetItem('160')
        TableWidget.setItem(0,2,newItem)

        layout.addWidget(TableWidget)

        self.setLayout(layout)
if __name__ == '__main__':
    app=QApplication(sys.argv)
    win=Table()
    win.show()
    sys.exit(app.exec_())

</code></pre>
<h3 id="实战">实战</h3>
<h4 id="firstapppy">FirstApp.py</h4>
<pre><code class="language-python">import sys
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from Tools import *


class FirstApp(QMainWindow):

    def __init__(self):
        super(FirstApp, self).__init__()

        Tools.create_db()
        # 创建ui布局
        self.init_main_ui()
        # 创建表格
        self.init_table()

    #布局
    def init_main_ui(self):

        self.resize(450, 270)
        self.setWindowTitle('FirstApp')
        self.qwidget = QWidget()
        self.tablewidget = QTableWidget()

        grid = QGridLayout()
        self.addButton = QPushButton('新增')
        self.editButton = QPushButton('修改')
        self.delButton = QPushButton('删除')

        #设置跨3列
        grid.addWidget(self.tablewidget,1,1,1,3)
        grid.addWidget(self.addButton,2,1)
        grid.addWidget(self.editButton,2,2)
        grid.addWidget(self.delButton,2,3)

        self.qwidget.setLayout(grid)

        self.setCentralWidget(self.qwidget)

        #给按钮绑定方法
        self.addButton.clicked.connect(self.addDef)
        self.editButton.clicked.connect(self.editDef)
        self.delButton.clicked.connect(self.delDef)

    def init_table(self):

        print ('初始化表格')

        self.tablewidget.setColumnCount(4)

        # 水平和垂直方向设置为正好填满表格
        self.tablewidget.horizontalHeader().setStretchLastSection(True)
        self.tablewidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        headerlabels = ['序号','网站', '账号', '密码']
        self.tablewidget.setHorizontalHeaderLabels(headerlabels)
        self.tablewidget.setEditTriggers(QAbstractItemView.NoEditTriggers)

        # 隐藏id列
        self.tablewidget.setColumnHidden(0, True);
        self.tablewidget.setShowGrid(False)
        # 隐藏表头
        #self.tablewidget.verticalHeader().hide()
        self.tablewidget.setSelectionBehavior(QAbstractItemView.SelectRows)

        self.flushTable()

    def flushTable(self):

        data_list = Tools.get_data()
        self.tablewidget.setRowCount(len(data_list))
        print (data_list)
        for index in range(len(data_list)):
            self.tablewidget.setItem(index,0,QTableWidgetItem(str(data_list[index][0])))
            self.tablewidget.setItem(index,1,QTableWidgetItem(data_list[index][1]))
            self.tablewidget.setItem(index,2,QTableWidgetItem(data_list[index][2]))
            self.tablewidget.setItem(index,3,QTableWidgetItem(data_list[index][3]))


    def addDef(self):

        return_tulpe = self.addDialog()




    def addDialogAccept(self):

        if self.ed1.text() != '' and self.ed2.text() != '' and self.ed3.text() != '':
            self.dialog.close()
            Tools.new_data(self.ed1.text(), self.ed2.text(), self.ed3.text())
            self.flushTable()
            self.showHint('新增成功')
        else:
            self.showHint('必填项不能为空')


    def addDialog(self, category='', content='', command=''):

        self.dialog = QDialog(self)
        group = QGroupBox(self.dialog)

        self.dialog.setWindowTitle('操作')
        # dialog.setWindowFlag(Qt.FramelessWindowHint)
        # 创建事件的标签和输入框
        lb1 = QLabel('类别:', group)
        self.ed1 = QLineEdit(group)
        self.ed1.setText(category)

        # 创建状态的标签和输入框
        lb2 = QLabel('名称:', group)
        self.ed2 = QLineEdit(group)
        self.ed2.setText(content)

        lb3 = QLabel('命令:', group)
        self.ed3 = QLineEdit(group)
        self.ed3.setText(command)
        # 创建确定和取消的按钮
        ok_button = QPushButton('确定', self.dialog)
        cancel_button = QPushButton('取消', self.dialog)

        # 布局
        group_layout = QVBoxLayout()
        group_item = [lb1, self.ed1, lb2, self.ed2, lb3, self.ed3]
        for item in group_item:
            group_layout.addWidget(item)

        group.setLayout(group_layout)
        group.setFixedSize(group.sizeHint())

        button_layout = QHBoxLayout()
        button_layout.addWidget(ok_button)
        button_layout.addWidget(cancel_button)

        dialog_layout = QVBoxLayout()
        dialog_layout.addWidget(group)
        dialog_layout.addLayout(button_layout)
        self.dialog.setLayout(dialog_layout)
        self.dialog.setFixedSize(self.dialog.sizeHint())

        # 绑定确定和取消按钮的功能
        ok_button.clicked.connect(self.addDialogAccept)
        ok_button.setDefault(True)
        cancel_button.clicked.connect(self.dialog.reject)

        self.dialog.exec_()
        return False

    def addDialogAccept(self):

        if self.ed1.text() != '' and self.ed2.text() != '' and self.ed3.text() != '':
            self.dialog.close()
            Tools.new_data(self.ed1.text(), self.ed2.text(), self.ed3.text())
            self.flushTable()
            self.showHint('新增成功')
        else:
            self.showHint('必填项不能为空')

    def editDef(self):
        # 选中某行
        selected_row = self.tablewidget.selectedItems()

        if len(selected_row) == 3:

            # 获取该行行号
            edit_row = self.tablewidget.row(selected_row[0])

            self.id = self.tablewidget.item(edit_row, 0).text()
            category = self.tablewidget.item(edit_row, 1).text()
            content = self.tablewidget.item(edit_row, 2).text()
            command = self.tablewidget.item(edit_row, 3).text()

            # 将获取到的选中行的数据赋予给修改窗口的方法，同时返回新数据
            self.editDialog(category, content, command)
        else:
            # 如果没有选中改行时，点击编辑，弹出提示框
            self.showHint(&quot;请选中一行进行编辑&quot;)


    def editDialog(self, category='', content='', command=''):

        self.dialog = QDialog(self)
        group = QGroupBox(self.dialog)

        self.dialog.setWindowTitle('操作')
        # dialog.setWindowFlag(Qt.FramelessWindowHint)
        # 创建事件的标签和输入框
        lb1 = QLabel('类别:', group)
        self.ed1 = QLineEdit(group)
        self.ed1.setText(category)

        # 创建状态的标签和输入框
        lb2 = QLabel('名称:', group)
        self.ed2 = QLineEdit(group)
        self.ed2.setText(content)

        lb3 = QLabel('命令:', group)
        self.ed3 = QLineEdit(group)
        self.ed3.setText(command)
        # 创建确定和取消的按钮
        ok_button = QPushButton('确定', self.dialog)
        cancel_button = QPushButton('取消', self.dialog)

        # 布局
        group_layout = QVBoxLayout()
        group_item = [lb1, self.ed1, lb2, self.ed2, lb3, self.ed3]
        for item in group_item:
            group_layout.addWidget(item)

        group.setLayout(group_layout)
        group.setFixedSize(group.sizeHint())

        button_layout = QHBoxLayout()
        button_layout.addWidget(ok_button)
        button_layout.addWidget(cancel_button)

        dialog_layout = QVBoxLayout()
        dialog_layout.addWidget(group)
        dialog_layout.addLayout(button_layout)
        self.dialog.setLayout(dialog_layout)
        self.dialog.setFixedSize(self.dialog.sizeHint())

        # 绑定确定和取消按钮的功能
        ok_button.clicked.connect(self.editDialogAccept)
        ok_button.setDefault(True)
        cancel_button.clicked.connect(self.dialog.reject)

        self.dialog.exec_()
        return False

    def editDialogAccept(self):

        if self.ed1.text() != '' and self.ed2.text() != '' and self.ed3.text() != '':
            self.dialog.close()
            Tools.edit_data(self.id,self.ed1.text(), self.ed2.text(), self.ed3.text())
            self.flushTable()
            self.showHint('修改成功')
        else:
            self.showHint('必填项不能为空')

    def showHint(self, message):

        hint_msg = QMessageBox()
        hint_msg.setText(message)
        hint_msg.addButton(QMessageBox.Ok)
        hint_msg.setWindowTitle(&quot;提示&quot;)
        hint_msg.exec_()

    def delDef(self):
        # 选中某行
        selected_row = self.tablewidget.selectedItems()
        if len(selected_row) == 3:

            del_row = self.tablewidget.row(selected_row[0])
            id = self.tablewidget.item(del_row, 0).text()
            print(id)
            if self.del_dialog() == True:
                Tools.del_data(id)
                self.flushTable()

        else:
            # 如果没有选中改行时，点击编辑，弹出提示框
            self.showHint(&quot;请选中一行进行删除&quot;)

    def del_dialog(self):
        del_dialog = QDialog(self)
        del_dialog.setWindowTitle(u'删除')
        group = QGroupBox('', del_dialog)
        lb1 = QLabel(u'确定删除吗?删除后无法恢复')
        # 创建确定和取消的按钮
        ok_button = QPushButton(u'确定', del_dialog)
        cancel_button = QPushButton(u'取消', del_dialog)

        # 绑定确定和取消按钮的功能
        ok_button.clicked.connect(del_dialog.accept)
        ok_button.setDefault(True)
        cancel_button.clicked.connect(del_dialog.reject)
        group_layout = QVBoxLayout()
        group_item = [lb1]
        for item in group_item:
            group_layout.addWidget(item)
        group.setLayout(group_layout)
        group.setFixedSize(group.sizeHint())

        button_layout = QHBoxLayout()
        button_layout.addWidget(ok_button)
        button_layout.addWidget(cancel_button)
        dialog_layout = QVBoxLayout()
        dialog_layout.addWidget(group)
        dialog_layout.addLayout(button_layout)
        del_dialog.setLayout(dialog_layout)
        del_dialog.setFixedSize(del_dialog.sizeHint())
        if del_dialog.exec_():
            return True
        return False

if __name__ == '__main__':
    app=QApplication(sys.argv)
    table=FirstApp()
    table.show()
    sys.exit(app.exec_())
</code></pre>
<h4 id="toolspy">Tools.py</h4>
<pre><code class="language-python">import sqlite3
import os

import codecs
import sqlite3
import os
import time


class Tools():

    @staticmethod
    def create_db():

        if os.path.exists('mydata.db') == False:
            connect = sqlite3.connect('mydata.db')
            c = connect.cursor()
            # 创建自增列
            c.execute('''create table mydata(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                Website varchar(1000),
                username varchar(1000),
                passwd varchar(1000)
            );
            ''')
            connect.commit()
            c.execute(&quot;insert into mydata values(1,'www.qq.com','1231412','test123')&quot;)
            connect.commit()
            connect.close()

    @staticmethod
    def get_data():

        conn = sqlite3.connect('mydata.db')
        c = conn.cursor()
        cursor = c.execute('select * from mydata')

        data_list = []
        for row in cursor:
            temp_list = []
            temp_list.append(row[0])
            temp_list.append(row[1])
            temp_list.append(row[2])
            temp_list.append(row[3])
            data_list.append(temp_list)
        conn.close()
        return data_list

    @staticmethod
    def new_data(website, username, passwd):

        connect = sqlite3.connect('mydata.db')
        c = connect.cursor()
        command = &quot;insert into mydata values(null,'%s','%s','%s')&quot; % (website, username, passwd)
        print(command)
        c.execute(command)
        connect.commit()
        connect.close()

    @staticmethod
    def edit_data(id, website, username, passwd):

        connect = sqlite3.connect('mydata.db')
        c = connect.cursor()
        print(1)
        command = &quot;update mydata set website='%s',username='%s',passwd='%s' where id=%s&quot; % (
        website, username, passwd, id)
        print(command)
        c.execute(command)
        connect.commit()
        connect.close()

    @staticmethod
    def del_data(id):
        print(33333)
        connect = sqlite3.connect('mydata.db')
        c = connect.cursor()
        print(1)
        command = &quot;delete from mydata where id = %s&quot; % id
        print(command)
        c.execute(command)
        connect.commit()
        connect.close()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[02——数据库基础]]></title>
        <id>https://childlike2333.github.io/post/02-shu-ju-ku-ji-chu/</id>
        <link href="https://childlike2333.github.io/post/02-shu-ju-ku-ji-chu/">
        </link>
        <updated>2020-04-06T02:23:45.000Z</updated>
        <content type="html"><![CDATA[<h4 id="数据库概念">数据库概念</h4>
<blockquote>
<p>数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。</p>
<p>​       所谓“数据库”系以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合</p>
</blockquote>
<blockquote>
<p>数据库管理系统，是为管理数据库而设计的电脑软件系统，一般具有存储、截图、安全保障、备份等基础功能</p>
</blockquote>
<blockquote>
<p>现在我们通常使用关系型数据库管理系统来存储和管理数据，所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p>
</blockquote>
<p>展示出来的界面：</p>
<figure data-type="image" tabindex="1"><img src="https://childlike2333.github.io/post-images/1586141496839.png" alt="" loading="lazy"></figure>
<p>实际存储数据内容：</p>
<figure data-type="image" tabindex="2"><img src="https://childlike2333.github.io/post-images/1586141533026.png" alt="" loading="lazy"></figure>
<ul>
<li>表头： 每一列的名称</li>
<li>列： 具有相同数据类型的数据的集合</li>
<li>行：每一行用来描述某条记录的具体信息</li>
<li>值：行的具体信息，每个值必须与该列的数据类型相同</li>
<li>键：特殊的列，这一列的值在当前列中具有唯一性</li>
</ul>
<h4 id="关系型数据库的特点">关系型数据库的特点</h4>
<ul>
<li>数据库以表格的形式出现</li>
<li>每行为各种记录名称</li>
<li>每列位记录名称所对应的数据域</li>
<li>许多的行和列组成一张表单</li>
<li>若干的表单组成 database 数据库</li>
</ul>
<h4 id="mysql数据库">MySQL数据库</h4>
<p>MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</p>
<ul>
<li>MySQL 是开源的，所以你不需要支付额外的费用。</li>
<li>MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>MySQL 使用标准的 SQL 数据语言形式。</li>
<li>MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。</li>
<li>MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。</li>
<li>MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。</li>
<li>MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统</li>
</ul>
<h4 id="mysql的安装">MySQL的安装</h4>
<blockquote>
<p>https://dev.mysql.com/downloads/mysql/ 官网提供了所有平台的MySQL版本下载，下载对应版本的MySQL，下载完成后根据引导安装即可。</p>
</blockquote>
<p>在windows下跟随引导安装mysql完成后，安装过程中会提示设置账号和密码，这里直接将账号和密码设置为root /root ,完成安装，想要在cmd中进入msyql的命令行，必须将mysql添加到系统环境变量Path路径中。</p>
<blockquote>
<p>C:\Program Files\MySQL\MySQL Server 5.6\bin</p>
</blockquote>
<p>在命令行中执行mysql -uroot -proot，进入到mysql的命令行</p>
<figure data-type="image" tabindex="3"><img src="https://childlike2333.github.io/post-images/1586141568182.png" alt="" loading="lazy"></figure>
<h4 id="navicat-数据库管理工具">Navicat 数据库管理工具</h4>
<p>下载并安装navicat进行数据库管理</p>
<h4 id="创建-删除数据库">创建、删除数据库</h4>
<p><code>create database 数据库名;</code></p>
<p><code>drop database 数据库名;</code></p>
<h4 id="选择数据库">选择数据库</h4>
<p><code>use 数据库名</code></p>
<p>接下来你的所有操作都会在这个数据库中执行</p>
<h4 id="mysql数据类型">MySQL数据类型</h4>
<p>在mysql中支持多种类型的数据结构，大致可以分为三类： 数值、时间和字符串。</p>
<ul>
<li>数值类型</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">(-128，127)</td>
<td style="text-align:left">(0，255)</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">(-32 768，32 767)</td>
<td style="text-align:left">(0，65 535)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3 字节</td>
<td style="text-align:left">(-8 388 608，8 388 607)</td>
<td style="text-align:left">(0，16 777 215)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:left">(0，4 294 967 295)</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td style="text-align:left">(0，18 446 744 073 709 551 615)</td>
<td style="text-align:left">极大整数值</td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td style="text-align:left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td style="text-align:left">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:left">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<ul>
<li>时间类型</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小 (字节)</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01/9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left">'-838:59:59'/'838:59:59'</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901/2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left">1000-01-01 00:00:00/9999-12-31 23:59:59</td>
<td style="text-align:left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">4</td>
<td style="text-align:left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td style="text-align:left">YYYYMMDD HHMMSS</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<ul>
<li>字符串类型</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">大小</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">0-65535 字节</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0-255字节</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">0-65 535字节</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">0-65 535字节</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0-16 777 215字节</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0-16 777 215字节</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGBLOB</td>
<td style="text-align:left">0-4 294 967 295字节</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0-4 294 967 295字节</td>
<td style="text-align:left">极大文本数据</td>
</tr>
</tbody>
</table>
<p>CHAR 和 VARCHAR 的区别：</p>
<p>定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p>
<h4 id="mysql创建数据表">MySQL创建数据表</h4>
<p><code>create table 表名 (字段名称，字段类型(长度));</code></p>
<pre><code class="language-mysql">#int后面不写长度，会给默认长度11
#一般来说 我们会把主键设置为 自动递增，每次增加一行数据，主键+1
create table school(
	school_id int auto_increment,
	school_code int(5),
	school_name varchar(100),
	school_addr varchar(100),
	insert_time datetime,
	primary key(school_id)
);
</code></pre>
<h4 id="删除数据表">删除数据表</h4>
<p><code>drop table 表名</code></p>
<p><code>drop table school;</code></p>
<h4 id="插入数据">插入数据</h4>
<pre><code class="language-mysql">insert into table_name (field1,field2,....)  values (value1,value2,....);
insert into table_name values (value1,value2,....);
</code></pre>
<pre><code class="language-mysql">#类似python中的位置参数和 关键字参数
insert into school(school_code,school_name,school_addr,insert_time)
values
(11111,&quot;北京大学&quot;,&quot;中国北京&quot;,now());
insert into school(school_code,school_name,school_addr,insert_time)
values
(22222,&quot;清华大学&quot;,&quot;中国北京&quot;,now());
insert into school(school_code,school_name,school_addr,insert_time)
values
(33333,&quot;北京科技大学&quot;,&quot;中国北京&quot;,now());
insert into school
values
(4,44444,&quot;哈佛大学&quot;,&quot;美国&quot;,now());
insert into school
values
(0,55555,&quot;哈尔滨佛学院&quot;,&quot;哈尔滨&quot;,now());
</code></pre>
<h4 id="查询数据">查询数据</h4>
<pre><code class="language-mysql">select 数据名称1,数据名称2
from 表名
where 条件
limit 查询条数
offset 查询偏移

# 查询全部
select * from school;

# 查询全部的学校编号和名字
select school_code,school_name from school;

# 查询来自中国北京的学校编码和名字
select school_code,school_name from school where school_addr = &quot;中国北京&quot;;

# 查询来自中国北京的学校编码和名字，只显示2条
select school_code,school_name from school where school_addr = &quot;中国北京&quot; limit 2;

# 查询来自中国北京的学校编码和名称，从第二条开始查询，只显示1条
select school_code,school_name from school where school_addr = &quot;中国北京&quot; limit 2 offset 2;
</code></pre>
<h4 id="where-语句">Where 语句</h4>
<blockquote>
<p>where 语句类似python语言中的if条件，检索出满足条件的数据，同时可以使用and or逻辑语句来查询</p>
</blockquote>
<pre><code class="language-mysql">select school_code,school_name from school where school_addr = &quot;中国北京&quot; and school_name = &quot;北京大学&quot;;

select school_code,school_name from school where school_addr = &quot;中国北京&quot; or school_addr = &quot;美国&quot;;
</code></pre>
<p>在where语句中还可以使用操作符来进行匹配</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">等号，检测两个值是否相等，如果相等返回true</td>
<td style="text-align:left">(A = B) 返回false。</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;, !=</td>
<td style="text-align:left">不等于，检测两个值是否相等，如果不相等返回true</td>
<td style="text-align:left">(A != B) 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td>
<td style="text-align:left">(A &gt; B) 返回false。</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td>
<td style="text-align:left">(A &lt; B) 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td>
<td style="text-align:left">(A &gt;= B) 返回false。</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于号，检测左边的值是否小于于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td>
<td style="text-align:left">(A &lt;= B) 返回 true</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">select school_code,school_name from school where school_id &gt;= 3;
</code></pre>
<h4 id="like语句">like语句</h4>
<pre><code># where 条件中还可以用like语句来进行模糊匹配
# 查询出名字包含北京的大学信息
# like通常和%一起使用，但是如果不使用%那么他的效果就和 =号一样
select school_code,school_name from school where school_name like &quot;北京%&quot;;
</code></pre>
<h4 id="更新数据">更新数据</h4>
<pre><code class="language-python">#将查询出来的结果中的字段进行更新，可以同时更新多个字段

update table_name set field1=new-value1,field2=new-value2
where 条件

update school set school_code=12345,school_addr='中国首都北京' where school_name = &quot;北京大学&quot;; 
</code></pre>
<h4 id="删除数据">删除数据</h4>
<pre><code class="language-mysql">#将查询出来的结果全部删除

delete from 表名 where 条件

delete from school where school_addr = &quot;美国&quot;;
</code></pre>
<h4 id="排序">排序</h4>
<pre><code class="language-mysql"># 将查询出来的结果排序
select 字段1，字段2 from 表1，表2
order by 字段1，字段2

select * from school order by school_code;

select * from school order by school_code desc;

select * from school order by school_code,school_name;

select * from school order by school_code,school_name desc;
</code></pre>
<h4 id="分组">分组</h4>
<pre><code>select 字段 from 表
where 条件
group by 字段;

select * from school
group by school_addr;

#计算出现的次数
select *,count(*) from school
group by school_addr;
</code></pre>
<h4 id="union-操作符">UNION 操作符</h4>
<blockquote>
<p>union操作符用于连接两个以上的select语句的结果组合到一个结果集合中</p>
</blockquote>
<pre><code class="language-mysql">select 字段名称1，字段名称2 from 表名
where 查询条件
union [all]
select 字段名称1，字段名称2 from 表名
where 查询条件
</code></pre>
<pre><code class="language-mysql">create table school(
	id int auto_increment,
	school_code int(5),
	school_name varchar(100),
	school_addr varchar(100),
	primary key(id)
);

insert into school(school_code,school_name,school_addr)
values
(11111,&quot;北京大学&quot;,&quot;中国北京&quot;),
(22222,&quot;清华大学&quot;,&quot;中国北京&quot;),
(33333,&quot;北京科技大学&quot;,&quot;中国北京&quot;),
(44444,&quot;哈佛大学&quot;,&quot;美国&quot;),
(55555,&quot;哈尔滨佛学院&quot;,&quot;中国哈尔滨&quot;);

create table student(
	id int auto_increment,
	student_name varchar(100),
	school_name varchar(100),
	primary key(id)
);

insert into student(student_name,school_name)
values
(&quot;张一&quot;,&quot;福州大学&quot;),
(&quot;李二&quot;,&quot;山东大学&quot;),
(&quot;苏四&quot;,&quot;北京大学&quot;),
(&quot;钱五&quot;,&quot;清华大学&quot;);

# union合并两个结果集，删除重复的数据
select school_name from school
union
select school_name from student;

select school_name,school_addr from school
union
select student_name,school_name from student;

#union合并两个结果集，不删除重复的数据
select school_name from school
union all
select school_name from student;
</code></pre>
<h4 id="聚合函数">聚合函数</h4>
<pre><code>用于对一组值进行统计，并且返回唯一值，这些函数被称为聚合函数
</code></pre>
<pre><code class="language-mysql">count()	统计记录的条数
sum()	求和函数，求出表中某个字段所有值的总和
avg()	求出某个字段，所有值的平均数
max()	求出某个字段的最大值
min()	求出某个字段的最小值

create table student(
	id int auto_increment,
	student_id varchar(100),
	student_name varchar(100),.
	student_grade int,
	primary key(id)
);

insert into student(student_id,student_name,student_grade)
values
(10101,&quot;小明&quot;,65),
(10101,&quot;小华&quot;,28),
(10101,&quot;小李&quot;,98),
(10101,&quot;小花&quot;,25),
(10101,&quot;小琴&quot;,98),
(10101,&quot;小马&quot;,100),
(10101,&quot;小宋&quot;,65);

select count(student_grade) from student;
select sum(student_grade) from student;
select avg(student_grade) from student;
select max(student_grade) from student;
select min(student_grade) from student;
</code></pre>
<h4 id="连接查询">连接查询</h4>
<p>SQL中的常用连接查询，交叉连接、内连接、外连接</p>
<blockquote>
<p>交叉连接：从一张表表中循环取出每一条记录，每条记录都去另外一张表进行匹配，最终形成的结果叫做笛卡尔积se</p>
</blockquote>
<pre><code class="language-mysql">select 字段1,字段2 from 表1 cross join 表2
select 字段1,字段2 from 表1，表2，

create table uniforms(
	id int auto_increment,
	model varchar(100),
	primary key(id)
);

insert into uniforms(model)
values
('a'),
('b'),
('c');

create table student(
	id int auto_increment,
	student_name varchar(100),
	school_name varchar(100),
	primary key(id)
);

insert into student(student_name,school_name)
values
(&quot;张一&quot;,&quot;福州大学&quot;),
(&quot;李二&quot;,&quot;山东大学&quot;),
(&quot;苏四&quot;,&quot;北京大学&quot;),
(&quot;钱五&quot;,&quot;清华大学&quot;);

select * from student,uniforms;
select * from student cross join uniforms;
select mode from student cross join uniforms;
</code></pre>
<blockquote>
<p>内连接: 组合两个表的记录，返回关联字段相符的记录，也就是返回两个表的交集部分</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="C:%5CWindows.old%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1568296973205.png" alt="1568296973205" loading="lazy"></figure>
<pre><code class="language-mysql">create table student(
	id int auto_increment,
	student_name varchar(100),
	school_name varchar(100),
	primary key(id)
);

insert into student(student_name,school_name)
values
(&quot;张一&quot;,&quot;福州大学&quot;),
(&quot;李二&quot;,&quot;山东大学&quot;),
(&quot;苏四&quot;,&quot;北京大学&quot;),
(&quot;钱五&quot;,&quot;清华大学&quot;);


create table student_grade(
	id int auto_increment,
	student_name varchar(100),.
	grade int,
	primary key(id)
);

insert into student_grade(student_name,grade)
values
(&quot;张一&quot;,65),
(&quot;李二&quot;,28),
(&quot;孟五&quot;,65),
(&quot;钱六&quot;,28);

select * from student join student_grade on student.student_name = student_grade.student_name;

select student.student_name,student.school_name,student_grade.grade from student join student_grade on student.student_name = student_grade.student_name;
</code></pre>
<blockquote>
<p>外连接:</p>
<p>分为 左连接 、右连接</p>
</blockquote>
<pre><code class="language-mysql">有null
select * from student left join student_grade on student.student_name = student_grade.student_name;

select * from student_grade left join student on student.student_name = student_grade.student_name;

有null
select * from student_grade right join student on student.student_name = student_grade.student_name;

select * from student right join student_grade on student.student_name = student_grade.student_name;
</code></pre>
<p>9856</p>
<h4 id="一对一关系">一对一关系</h4>
<blockquote>
<p>两个表，第一个表中的某一行与第二个表中的一行相关，同时第二个表中的某一行吗，也只与第一个表中的一行相关，这两个表为1对1关系。</p>
</blockquote>
<ul>
<li>一个表包含了太多的数据列，于是分离成两个表</li>
<li>为了划分不同的安全级别</li>
<li>常用的数据组成一个表</li>
</ul>
<table>
<thead>
<tr>
<th>学校表</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>学校资产表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>学校编码</td>
<td>学校名称</td>
<td>学校地址</td>
<td></td>
<td>id</td>
<td>学校表id（外键）</td>
<td>学校资产</td>
</tr>
<tr>
<td>1</td>
<td>11111</td>
<td>北京大学</td>
<td>中国北京</td>
<td></td>
<td>1</td>
<td>1</td>
<td>500</td>
</tr>
<tr>
<td>2</td>
<td>22222</td>
<td>清华大学</td>
<td>中国北京</td>
<td></td>
<td>2</td>
<td>2</td>
<td>400</td>
</tr>
<tr>
<td>3</td>
<td>33333</td>
<td>北京科技大学</td>
<td>中国北京</td>
<td></td>
<td>3</td>
<td>3</td>
<td>300</td>
</tr>
<tr>
<td>4</td>
<td>44444</td>
<td>哈佛大学</td>
<td>美国</td>
<td></td>
<td>4</td>
<td>4</td>
<td>500</td>
</tr>
<tr>
<td>5</td>
<td>55555</td>
<td>哈尔滨佛学院</td>
<td>中国哈尔滨</td>
<td></td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">create table school(
	id int auto_increment,
	school_code int(5),
	school_name varchar(100),
	school_addr varchar(100),
	primary key(id)
);
insert into school(school_code,school_name,school_addr)
values
(11111,&quot;北京大学&quot;,&quot;中国北京&quot;),
(22222,&quot;清华大学&quot;,&quot;中国北京&quot;),
(33333,&quot;北京科技大学&quot;,&quot;中国北京&quot;),
(44444,&quot;哈佛大学&quot;,&quot;美国&quot;),
(55555,&quot;哈尔滨佛学院&quot;,&quot;中国哈尔滨&quot;);

# unique表示唯一性
create table assets(
	id int auto_increment,
	assets_num int,
	school_id int unique,
    primary key(id),
	constraint fk_school foreign key(school_id) references school(id)
);

insert into assets(assets_num,school_id)
values
(500,1),
(400,2),
(300,3),
(500,4),
(5,5);

select * from school a left join assets b on a.id = b.school_id;

</code></pre>
<h4 id="一对多关系">一对多关系</h4>
<blockquote>
<p>第一张表的一行可以与第二张表的多行相对应</p>
<p>一对多关系是最常见的关系类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>学校表</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>学校编码</td>
<td>学校名称</td>
<td>学校地址</td>
</tr>
<tr>
<td>1</td>
<td>11111</td>
<td>北京大学</td>
<td>中国北京</td>
</tr>
<tr>
<td>2</td>
<td>22222</td>
<td>清华大学</td>
<td>中国北京</td>
</tr>
<tr>
<td>3</td>
<td>33333</td>
<td>北京科技大学</td>
<td>中国北京</td>
</tr>
<tr>
<td>4</td>
<td>44444</td>
<td>哈佛大学</td>
<td>美国</td>
</tr>
<tr>
<td>5</td>
<td>55555</td>
<td>哈尔滨佛学院</td>
<td>中国哈尔滨</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>老师表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>id</td>
<td>老师编码</td>
<td>老师名字</td>
<td>老师所属学校id</td>
</tr>
<tr>
<td>1</td>
<td>101</td>
<td>李白</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>杜甫</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>103</td>
<td>白居易</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>201</td>
<td>孟浩然</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>202</td>
<td>李贺</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>301</td>
<td>苏轼</td>
<td>3</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">create table teacher(
	id int auto_increment,
	teacher_code int,
	teacher_name varchar(100),
	school_id int,
	primary key(id),
	constraint fk_teacher foreign key(school_id) references school(id)
);

insert into teacher(teacher_code,teacher_name,school_id)
values
(101,&quot;李白&quot;,1),
(102,&quot;杜甫&quot;,1),
(103,&quot;白居易&quot;,1),
(104,&quot;孟浩然&quot;,2),
(202,&quot;李贺&quot;,2),
(301,&quot;苏轼&quot;,3);
</code></pre>
<h4 id="多对多关系">多对多关系</h4>
<blockquote>
<p>多对多的关系是无法直接在两张表中表示关系的，需要借助第三张表</p>
</blockquote>
<table>
<thead>
<tr>
<th>老师表</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>老师-学生表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>老师编码</td>
<td>老师名字</td>
<td>老师所属学校id</td>
<td></td>
<td>id</td>
<td>老师id</td>
<td>学生id</td>
</tr>
<tr>
<td>1</td>
<td>101</td>
<td>李白</td>
<td>1</td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>102</td>
<td>杜甫</td>
<td>1</td>
<td></td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>103</td>
<td>白居易</td>
<td>1</td>
<td></td>
<td>3</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>201</td>
<td>孟浩然</td>
<td>2</td>
<td></td>
<td>4</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>202</td>
<td>李贺</td>
<td>2</td>
<td></td>
<td>5</td>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>301</td>
<td>苏轼</td>
<td>3</td>
<td></td>
<td>6</td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>7</td>
<td>2</td>
<td>7</td>
</tr>
<tr>
<td>学生表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>8</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>id</td>
<td>学生学号</td>
<td>学生名字</td>
<td></td>
<td></td>
<td>9</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>10101</td>
<td>小明</td>
<td></td>
<td></td>
<td>10</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>10102</td>
<td>小华</td>
<td></td>
<td></td>
<td>11</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>10103</td>
<td>小李</td>
<td></td>
<td></td>
<td>12</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>4</td>
<td>10104</td>
<td>小花</td>
<td></td>
<td></td>
<td>13</td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>5</td>
<td>10105</td>
<td>小琴</td>
<td></td>
<td></td>
<td>14</td>
<td>3</td>
<td>7</td>
</tr>
<tr>
<td>6</td>
<td>10106</td>
<td>小马</td>
<td></td>
<td></td>
<td>15</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td>10107</td>
<td>小宋</td>
<td></td>
<td></td>
<td>16</td>
<td>3</td>
<td>2</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">create table teacher(
	id int auto_increment,
	teacher_code int,
	teacher_name varchar(100),
	primary key(id)
);

insert into teacher(teacher_code,teacher_name)
values
(101,&quot;李白&quot;),
(102,&quot;杜甫&quot;),
(103,&quot;白居易&quot;),
(104,&quot;孟浩然&quot;),
(202,&quot;李贺&quot;),
(301,&quot;苏轼&quot;);

create table student(
	id int auto_increment,
	student_id int,
	student_name varchar(100),
	primary key(id)
);

insert into student(student_id,student_name)
values
(10101,&quot;小明&quot;),
(10101,&quot;小华&quot;),
(10101,&quot;小李&quot;),
(10101,&quot;小花&quot;),
(10101,&quot;小琴&quot;),
(10101,&quot;小马&quot;),
(10101,&quot;小宋&quot;);

create table tearcher2student(
id int auto_increment,
teacher_id int,
student_id int,
constraint fk_student2 foreign key(student_id) references student(id),
constraint fk_tearcher2 foreign key(teacher_id) references teacher(id),
primary key(id)
);

insert into tearcher2student(teacher_id,student_id)
values
(1,1),
(1,2),
(1,3),
(1,4),
(1,5),
(1,6),
(1,7),
(2,1),
(2,2),
(2,3),
(2,4),
(3,5),
(3,6),
(3,7);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[01——Python基础]]></title>
        <id>https://childlike2333.github.io/post/01-python-ji-chu/</id>
        <link href="https://childlike2333.github.io/post/01-python-ji-chu/">
        </link>
        <updated>2020-04-06T02:23:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="python简介">Python简介</h3>
<h4 id="起源">起源</h4>
<p>Python的创始人为 吉多·范罗苏姆（Guido van Rossum）。1989年圣诞节期间，他为了打发时间，决心开发一个新的脚本解释程序，在1991年，第一个python解释器诞生，他是用c语言实现的。</p>
<h4 id="设计哲学">设计哲学</h4>
<p>明确、优雅、简单</p>
<h4 id="主要应用领域">主要应用领域</h4>
<p>云计算：云计算最火的语言，典型应用OpenStack</p>
<p>Web开发：众多优秀的Web框架，Django、flask Youtube、豆瓣</p>
<p>科学运算、人工智能：NumPy, SciPy, Matplotlib, Enthought</p>
<p>系统运维：运维人员必备语言</p>
<p>图形GUI：PyQt、WxPython、Tkinter</p>
<h4 id="分类">分类</h4>
<ul>
<li>
<p>编译型： 把源程序的每一条语句都编译成机器语言，并保存成二进制文件  c  c++ go ...</p>
</li>
<li>
<p>解释型： 只有，在执行程序时才一条一条的解释成机器语言给计算机去执行  python ruby php javascript</p>
</li>
<li>
<p>混合型： java c#</p>
</li>
</ul>
<h4 id="编译和解释的区别">编译和解释的区别</h4>
<p>编译器：是把源程序的每一条语句都编译成机器语言，并保存二进制文件，这样运行时，计算器可以直接以机器语言来运行此程序，速度很快。因为编译只做一次，运行时不需要编译，所以编译型语言的程序执行效率高。缺点，如果需要修改，就需要整个模块重新编译。</p>
<p>解释器：只是在执行程序时，才一条一条的解释成机器语言来计算机来执行，所有运行速度是不如编译后的程序运行的快。优点，有良好的平台兼容性，在任何安装了解释器的平台都可以使用。缺点，每次运行的时候都要解释一遍，性能上不如编译性语言。</p>
<h4 id="优点">优点</h4>
<ul>
<li>
<p>优雅、明确、简单，快速入门</p>
</li>
<li>
<p>开发效率非常高，有非常强大的第三方库，避免重复造轮子</p>
</li>
<li>
<p>高级语言，开发的时候无需关心，内存一类的底层细节</p>
</li>
<li>
<p>可移植性强，如果的代码不依赖系统特性，那么你的python程序无需修改就可以在市场上所有的系统平台上运行 ifconfig ipconfig</p>
</li>
<li>
<p>可拓展性，如果你的一段关键代码需要运行的很快，那么你可以你这段代码用C或者C++来写，然后用Python调用他们就可以</p>
</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>
<p>速度慢，运行度相对于C和C++ 甚至java都要慢很多</p>
</li>
<li>
<p>假多线程，线程不能利用多核CPU，GIL全局解释锁，由于这个锁的存在，使得任何时刻仅有一个线程在执行</p>
</li>
</ul>
<h3 id="环境安装">环境安装</h3>
<h4 id="重大版本">重大版本</h4>
<p>Python2 和 Python3，主要差异在 print、编码、整数相除等，为了对Python3进行推广，预计 Python 2 到 2020 年 4 月 12 日就不再维护了，Python 2 将停止所有的更新，包括安全性更新。所以后续我们直接使用Python3就可以了。其实语法上差别并不大，稍微注意一下就可以了。</p>
<h4 id="下载">下载</h4>
<figure data-type="image" tabindex="1"><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="img" loading="lazy"></figure>
<p>一路确定即可</p>
<h3 id="第一个python程序">第一个Python程序</h3>
<h4 id="交互模式">交互模式</h4>
<p>输入python进入交互模式，这时候我们可以直接编写Python程序</p>
<figure data-type="image" tabindex="3"><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img" loading="lazy"></figure>
<h4 id="文件模式">文件模式</h4>
<p>创建一个文件，文件后缀为.py ,在文件中编写代码，通过python命令来执行解释这个文件，运行代码</p>
<figure data-type="image" tabindex="4"><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg" alt="img" loading="lazy"></figure>
<h4 id="pycharm">PyCharm</h4>
<p>后续我们会在 集成开发环境Pycharm中来进行学习，在官网中下载这个软件，安装后打开即可，默认情况下Pycharm会自动关联python解释器，不需要进行额外的配置，直接创建一个项目，就可以开始编写代码了。</p>
<figure data-type="image" tabindex="5"><img src="file:///C:/Users/ADMINI~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img" loading="lazy"></figure>
<h3 id="基础语法">基础语法</h3>
<h4 id="引入变量和数据类型">引入变量和数据类型</h4>
<pre><code>a = 1

b = 2

c = a + b

print (c)
</code></pre>
<p>abc为变量  1、2是整数</p>
<h4 id="变量">变量</h4>
<p>变量的定义：</p>
<p>将运算的中间结果暂存到内存，以便后续程序调用</p>
<p>变量的命名规则：</p>
<ul>
<li>
<p>变量一般由 字母、数字、下划线搭配组成</p>
</li>
<li>
<p>可以用数字开头，更不能是全数字</p>
</li>
<li>
<p>不能是python的关键字，关键字就是被python占用的单词，不可以使用</p>
</li>
</ul>
<pre><code>['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
</code></pre>
<ul>
<li>
<p>可以是中文，但不要用中文</p>
</li>
<li>
<p>名字要有意义</p>
</li>
<li>
<p>不要太长</p>
</li>
<li>
<p>区分大小写，大写的A 和小写的 a是两个不一样的变量</p>
</li>
</ul>
<p>变量命名方法:</p>
<p>下划线： student_first_name</p>
<p>小驼峰： studentFirstName</p>
<p>大驼峰： StudentFirstName</p>
<h4 id="常量">常量</h4>
<p>在python中不存在绝对的常量，我们约定，所有字母大写的变量，就是常量</p>
<p>PI = 3.141592635</p>
<h4 id="注释">注释</h4>
<p>有时候我们写的东西不一定都是给用户看的，或者不希望解释器执行，那么我们就注释掉代码，被注释的内容是不会被执行的。</p>
<pre><code>   单行注释： # 注释内容

   多行注释：
      '''
                  这里面的内容都是被注释掉的
      '''
</code></pre>
<h3 id="数字类型">数字类型</h3>
<h4 id="定义">定义</h4>
<p>我们人类可以很容易的分清楚数字和字符的区别，但计算机并不能，我们要明确的告诉他，1是数字，a是字符，所以在每个编程语言里面，都会有一个叫数据类型的东西，其实就是对常用的各种数据类型进行了明确的划分。</p>
<h4 id="分类-2">分类</h4>
<ul>
<li>
<p>数字型  int float bool complex</p>
</li>
<li>
<p>字符串  str</p>
</li>
<li>
<p>列表   list</p>
</li>
<li>
<p>元组   tuple</p>
</li>
<li>
<p>字典   dict</p>
</li>
<li>
<p>集合   set</p>
</li>
</ul>
<h4 id="数字类型-int-float-bool-complex">数字类型 （int float bool complex）</h4>
<p>整数 int</p>
<p>就是 -1 -2 -3 ，1 2 3 …</p>
<p>在32位机器上，int的范围是 -2<strong>31～2</strong>31-1，即-2147483648～2147483647</p>
<p>在64位机器上，int的范围是 -2<strong>63～2</strong>63-1，即-9223372036854775808～9223372036854775807</p>
<p>浮点 float</p>
<p>其实就是我们说的小数 1.2 -2.3 …</p>
<pre><code>a = 1

b = 1.1

c = a + b
</code></pre>
<p>整数 + 浮点数 = 浮点数</p>
<p>布尔 bool</p>
<p>真 或 假</p>
<p>True  False</p>
<p>复数 complex</p>
<p>a = 4+3j</p>
<h4 id="基本运算符">基本运算符</h4>
<ul>
<li>算数运算：</li>
</ul>
<p>+  加</p>
<p>-   减</p>
<p>*  乘</p>
<p>/  除</p>
<p>%  取模   返回除法的余数</p>
<p>** 幂</p>
<p>// 取整除，返回商的整数部分</p>
<ul>
<li>比较运算：</li>
</ul>
<p>==    比较对象是否相等 相等 返回true</p>
<p>！=    判断对象是否不相等</p>
<p>&gt;     判断大于</p>
<p>&lt;     判断小于</p>
<p>&gt;=    判断大于等于</p>
<p>&lt;=    判断小于等于</p>
<ul>
<li>赋值运算：</li>
</ul>
<p>​      =  赋值</p>
<p>​      += 加法赋值运算符      c+=a   c=c+a</p>
<p>​      类似的还有   -=    *=   /=   %=   //=</p>
<ul>
<li>
<p>逻辑运算：</p>
<p>and  与    如果x为False,  x and y返回False，否则返回y的计算值</p>
</li>
</ul>
<p>​      (3 and (2+2))  // 如果是0 ，直接返回 0</p>
<p>or 或     如果x是True，他返回x，否则它返回y的计算值</p>
<p>​      (4 or (3))</p>
<p>not   非</p>
<ul>
<li>
<p>逻辑常用：</p>
<p>and   True and False  只要有一个是假，那么结果就是假</p>
<p>or    True and False  只要有一个是真，那么结果就是真</p>
</li>
</ul>
<h3 id="字符串">字符串</h3>
<h4 id="字符串定义">字符串定义</h4>
<p>在Python中，凡是用引号引起来的，全部都是字符串</p>
<p>引号可以是 单引号、双引号和三引号</p>
<pre><code>   a = 'Hello'

   b = 'World'
</code></pre>
<h4 id="字符运算符">字符运算符</h4>
<p>​      +  字符串连接   a+b    'HelloWorld'</p>
<p>​      *  重复输出字符串   a * 2 'HelloHello'</p>
<p>​      [] 通过索引获取字符串中的字符  a[2]  l   a[-1] o</p>
<p>​      [:]   截取字符串中的一部分内容，遵循左闭右开原则</p>
<p>​            a[1:3]   el</p>
<p>​            a[:3]    Hell</p>
<p>​            a[3:]    lo</p>
<p>​            a[1:-2]   el</p>
<p>​      in 成员运算符    如果字符串中包含给定的字符，返回True</p>
<p>​      not in   如果字符串中不包含给定的字符串，就返回True</p>
<h4 id="字符串常用的方法">字符串常用的方法</h4>
<pre><code class="language-python">   lower()  #全部转为小写

   upper()  #全部转为大写

   swapcase()   #大小写互相转换

   strip()  #去掉两端的空格

   lstrip()  #去掉左边空格

   rstrip()  #去掉右边空格

   len('hello') #计算字符串的长度

   replace('a','b')   #字符串替换

   split(' ')   #字符串切割    转为列表
</code></pre>
<h4 id="格式化输出">格式化输出</h4>
<p>int  %d</p>
<p>float %f</p>
<p>string %s</p>
<pre><code class="language-python">a = 1

b = 2

c = 1.2

d = 2.3

e = 'JONE'

f = 'TACA'

print ('a= %d,b= %d'%(a,b))

print ('c= %f,c= %f'%(c,d))

print ('e= %s,d= %s'%(e,f))

print ('a= %d,d= %s'%(a,f))
</code></pre>
<h3 id="流程控制">流程控制</h3>
<h4 id="条件控制引入">条件控制引入</h4>
<p>我们在生活中经常会遇到各种各样的选择，比如玩骰子，石头剪刀布时，你就需要做出你的选择，在写代码的时候，我们也会遇到这种情况，这就需要用到if条件控制语句。</p>
<h4 id="条件控制语法">条件控制语法</h4>
<ul>
<li>
<p>语法1</p>
<pre><code class="language-python">if 条件1:		#冒号后换行，将条件与结果分开
	结果1		#用一个tab或者四个空格的代码缩进来控制代码作用域
结果2

scores = 60
if scores &gt;= 60:
	print ('及格了')
print ('6666')
</code></pre>
</li>
<li>
<p>语法2</p>
<pre><code class="language-python">if 条件1:
	结果1
else:
	结果2
	
scores = 59
if scores &gt;= 60:
	print ('及格了，6666')
else:
	print ('不及格，gg')
</code></pre>
</li>
<li>
<p>语法3</p>
<pre><code class="language-python">if 条件1：
	结果1
elif 条件2：
	结果2
...
else:
	结果3
	
scores = 80
if scores &gt;= 90:
	print ('牛逼')
elif scores &gt;= 80:
	print ('优秀')
elif scores &gt;= 60:
	print ('及格')
else:
	print ('不及格')
</code></pre>
</li>
<li>
<p>语法4</p>
<pre><code class="language-python">if 条件1:
	结果2
	if 条件2:
		结果2
	else 条件3：
		结果3
else:
	结果4

#可以无限的嵌套，但是在实际开发中，尽量不要超过三层
scores = 99
if scores &gt;= 80:
	print ('优秀')
	if scores &gt;= 90:
		print ('牛逼')
	else:
		print ('不够牛逼')
else:
	print ('不够优秀')
</code></pre>
</li>
</ul>
<h4 id="循环语句引入">循环语句引入</h4>
<p>在代码，我们有时需要重复的去做一些事情，比如打印100次hello，此时写 100遍print显然不太合适，这是我们会用到循环。</p>
<h4 id="循环语句语法">循环语句语法</h4>
<pre><code class="language-python">#当判断条件为真的时候，执行语句
while 判断条件:
    语句

a = 1
while a &lt; 10:
    print (a)
    a = a + 1
else:
    print a

while True:
    print (100)
    
</code></pre>
<pre><code class="language-python">#for循环
for 变量 in 范围:
    语句

a = 'helloworld'
for var in a:
    print (var)

#在0-10的范围内，遵循左闭右开原则
for var in range(10):
    print (var)
</code></pre>
<h4 id="跳出循环">跳出循环</h4>
<p>break 语句可以跳出for和while的循环体，从循环中终止</p>
<pre><code class="language-python">for var in range(10):
    print (var)
    if var == 5:
        break
#当变量==5时，跳出循环
</code></pre>
<p>continue语句用来告诉Python跳过当次循环中的剩余语句，直接执行下一次循环</p>
<pre><code class="language-python">for var in range(10):
	if var == 5:
		continue
	print (var)
</code></pre>
<p>Pass语句是空语句，是为了保持程序结果的完整性，不做任何的事情，一般用作占位语句</p>
<pre><code class="language-python">for var in range(10):
	if var == 5:
		pass
	else:
		print (var)
</code></pre>
<h3 id="列表">列表</h3>
<h4 id="列表的引入">列表的引入</h4>
<p>列表是最常用的Python数据类型之一。</p>
<p>创建一个列表，只需要把逗号分隔的不同的数据项，使用方括号括起来即可。</p>
<pre><code class="language-python">list1 = ['Hello','World',1997,6.6]
list2 = [1,2,3,4,5]
</code></pre>
<h4 id="访问列表中的值">访问列表中的值</h4>
<p>可以使用下表索引来访问列表中的值，同样也可以使用方括号的形式切片截图列表的值，这样会生成一个新的列表，和字符串的索引、切片用法一致。切片时，同样遵循左闭右开的原则。</p>
<pre><code>list1 = ['Hello','World',1997,6.6]
print (list1[1])
print (list1[1:-1])
</code></pre>
<h4 id="增加列表的项">增加列表的项</h4>
<p>注意，list和str是不一样的，list是可以发生改变的，直接操作原来的对象，那么对象就会直接改变</p>
<pre><code class="language-python">var = 'hello'
var + 'world'
print (var)

list1 = ['hello','test','good']
list1.append('yes')
print (list1)

#在最后增加 append
list1.append('no')
print (list1)

#在中间插入
list1.insert(2,'get')
print (list1)

#列表拓展，在最后插入一个列表
extend_list = ['make','gppp']
list1.extend(extend_list)
print (list1)
</code></pre>
<h4 id="删除列表的项">删除列表的项</h4>
<pre><code class="language-python">list1 = ['hello','test','good','make','yes']

#pop(),如果不写参数默认删除最后一项，写参数可以指定删除的项
list1.pop()
print (list1)

list1.pop(3)
print (list1)

#remove,删除指定元素
list1.remove('test')
print (list1)

#del,按下表或者索引删除
list1 = ['hello','test','good','make','yes']
del list1[1]
print (list1)
del list1[1:3]
print (list1)

#clear 清空整个列表
list1.clear()
</code></pre>
<h4 id="修改列表的值">修改列表的值</h4>
<p>通过索引和切片的方式直接修改</p>
<pre><code class="language-python">list1 = ['hello','test','good','make','yes']
list1[2] = 'no'
print (list1)

#如果长度不够，直接往后增加
list1[1:2] = ['thanks','you']
print (list1)

#如果长度太长，直接删除
list1[1:4] = ['thanks','you']
print (list1)

#几乎不这么用，知道就行
</code></pre>
<h4 id="其他操作">其他操作</h4>
<pre><code class="language-python">list1 = [1,2,3,4,1,2,3,3,4]
# 计算1在列表中出现的次数
num = list1.count(1)	
print (num)
# 排序
list1.sort()
print (list1)
# 倒序
list1.sort(reverse=True)
print (list1)
list1 = [1,2,3,4,1,2,3,3,4]

# 列表反转
list1.reverse()
print (list1)
print (len(list1))

#如果是字符串，会按照字母顺序来排序
list1 = ['speed','test','as','country']
list1.sort()
print (list1)

#遍历列表
for var in list1:
    print (var)
</code></pre>
<h4 id="列表的嵌套">列表的嵌套</h4>
<pre><code>list1 = [1,2,3,4]
list2 = [1,2,3,4,list1]

#一层一层看即可，并不复杂
print (list2[4][1])
</code></pre>
<h3 id="字典">字典</h3>
<h4 id="字典的简单介绍">字典的简单介绍</h4>
<p>字典是python中唯一的一个映射类型，他是以大括号括起来的键值对组成。</p>
<pre><code>dict1 = {'a':11 , 'b': 222,'123':'22'}
</code></pre>
<p>在字典中，键是唯一的，值可以重复。在保存的时候，根据key来计算出一个内存地址，然后将key-value保存在这个地址中，这种算法被称为hash算法，所以，在dict中，这个key必须是可哈希的，如果你现在还搞不懂什么是可哈希的，暂时可以这样记，可以改变的都是不可哈希的，可以哈希的都不可以变。</p>
<p>可哈希（不可变）：	num  str  tuple  bool</p>
<p>不可哈希的 （可变的）：	list   dict  set</p>
<p>字典保存的时候，并不是按照我们添加进入的顺序保存的，是按照hash表的顺序保存的，而hash表不是连续的，所以它是不支持下表索引和切片的，它只能通过key来获取dict中的数据。</p>
<h4 id="访问字典的值">访问字典的值</h4>
<pre><code class="language-python">dict1 = {'name':'xiaoming','sex':'man'}
print (dict1['name'])

# print (dict1['test'])	没有这个值的时候会报错

print (dict1.get('sex'))
# 没有找到时打出 None
print (dict1.get('test'))
</code></pre>
<h4 id="增加和修改">增加和修改</h4>
<pre><code class="language-python">dict1 = {}
# 如果字典中没有出现这个key，就会新增一个这个键值对 
dict1['name'] = 'xiaoming'

#如果字典中已经有这个key，就会修改这个值
dict1['name'] = 'xiaohua'

dict2 = {'name':'xiaowang','sex':'man'}
dict1.update(dict2)
#把dict2中的内容更新到dict1中，如果key存在，就替换，如果key不存在，就新增
print (dict1)
</code></pre>
<h4 id="删除">删除</h4>
<pre><code class="language-python">dict1 = {'name':'xiaoming','sex':'man','scores':88}
#索引删除
del dict1['name']
print (dict)

#随机删除
dict.popitem()
print (dict)

#清空字典
dict.clear()
print (dict)
</code></pre>
<h4 id="其他操作-2">其他操作</h4>
<pre><code class="language-python">#获取字典的键列表
dict1 = {'name':'xiaoming','sex':'man','scores':88}
print (dict1.keys())

#获取字典的值列表
print (dict1.values())

#遍历字典
for temp in dict1.keys():
	print (temp)
	print (dict1[temp])
    
#字典嵌套
dict2 = {'name':'xiaohua','sex':'girl','dict1':dict1}
print (dict2['dict1']['name'])
</code></pre>
<h3 id="元组">元组</h3>
<h4 id="元组的简单介绍">元组的简单介绍</h4>
<p>元组和列表类似，不同之处在于元组的元素不能修改，元组使用小括号</p>
<pre><code class="language-python">tup1 = (50)
#不加逗号，类型为整数
print type(tup1)

#加上逗号，才是元组
tup2 = (50,)
print type(tup2)
</code></pre>
<h4 id="访问元组的值">访问元组的值</h4>
<p>元组可以通过索引和切片的方式来访问值，和列表一致，不作拓展</p>
<h4 id="删除-2">删除</h4>
<pre><code class="language-python">#元组不允许修改和删除单个值，只能整个删除
tup1 = (50,20)
del tup1
print (tup1)

</code></pre>
<h3 id="集合">集合</h3>
<h4 id="集合的基本介绍">集合的基本介绍</h4>
<p>set集合是python的一个基本数据类型，一般不是很常用，简单了解一下即可</p>
<p>用大括号括起来，set中的元素是不重复、无序的，其实就是类似dict类型的key，但是不保存 value，所以里面的类型必须是可hash的</p>
<pre><code class="language-python">set1 = {1,2,3,4,'xiaoming'}
set2 = {1,1,2,3,'xiaoming','xiaoming'}
print (set1)
print (set2)
</code></pre>
<h4 id="集合的常用操作">集合的常用操作</h4>
<p>add 增加</p>
<p>pop 随机删除一个</p>
<p>remove 根据元素删除</p>
<p>clear 清空set集合</p>
<pre><code class="language-python"># 利用set的特性来进行列表去重
list1 = [1,1,1,12,4,23,42,4,4]
list2 = list(set(list1))
print (list2)
</code></pre>
<h3 id="函数">函数</h3>
<h4 id="函数的引入">函数的引入</h4>
<p>为什么要有函数，比如看下面的例子：</p>
<pre><code class="language-python">scores = 88
if scores &gt;= 60 :
	print ('及格了')
else :
	print ('不及格')
	
scores = 56
if scores &gt;= 60 :
	print ('及格了')
else :
	print ('不及格')
</code></pre>
<p>如果只有几个同学，可能复制几遍就可以了，但是如果全班同学大几十个人，要怎么去做统计呢。引入函数的概念，我们定义一个事情或者功能，等到需要的时候直接去用就可以了，那里这里定义的东西就是一个函数。</p>
<p>函数是组织好的，可重复使用的，用来实现单一、或者相关联功能的代码块。</p>
<p>函数能提高应用的模块性和代码的重复利用率。print()这就是python的一个内建函数，我们也可以自己创建函数，这被叫做用户自定义函数。</p>
<h4 id="语法">语法</h4>
<pre><code class="language-python">def 函数名(参数列表):
	函数体
    
#函数名的命名和变量的命名规则一致，复习下    
#简单的函数实例
def hello():
    print ('hello world')

#执行函数
hello()
</code></pre>
<h4 id="参数">参数</h4>
<p>形参：写在函数生命位置的变量叫形参，形式上的一个完整，表示这个函数调用时需要一个参数。</p>
<p>实参：在函数调用的时候给函数传递的值，叫实参。</p>
<p>传参：将实际参数交给形式参数的过程被称为传参</p>
<pre><code class="language-python">#带参数的函数实例
def helloSomeone(name):
	print ('hello %s' %name)
    
helloSomeone('xiaoming')
</code></pre>
<p>形参的分类：</p>
<pre><code class="language-python">#按位置顺序排序的参数
def helloSomeone(name1,name2):
	print ('hello %s' %name1)
	print ('hello %s' %name2)
    
helloSomeone('xiaoming','xiaohua')

#name2就是一个默认值参数，在调用函数的时候，如果不给它传参，就会使用默认值
def helloSomeone(name1,name2='xiaohua'):
	print ('hello %s' %name1)
	print ('hello %s' %name2)
    
helloSomeone('xiaoming','xiaoqiang')
helloSomeone('xiaoming')
</code></pre>
<p>实参的分类：</p>
<pre><code>#位置参数，按位置来传参
def helloSomeone(name1,name2):
	print ('hello %s' %name1)
	print ('hello %s' %name2)
    
helloSomeone('xiaoming','xiaohua')

#关键字参数，按关键字来传参
def helloSomeone(name1,name2):
	print ('hello %s' %name1)
	print ('hello %s' %name2)
    
helloSomeone(name1='xiaoming',name2='xiaohua')

#混合参数，位置参数必须在关键字参数前面
def helloSomeone(name1,name2,name3):
	print ('hello %s' %name1)
	print ('hello %s' %name2)
	print ('hello %s' %name3)
helloSomeone('xiaoming','xiaohua','xiaoqiang')
helloSomeone('xiaoming',name2='xiaohua',name3='xiaoqiang')

#保存
helloSomeone(name1='xiaoming',name2='xiaohua','xiaoqiang')
</code></pre>
<h4 id="返回值">返回值</h4>
<p>return语句用于退出函数，并且在退出的时候选择性的向调用方返回一个表达式，不带参数值的return语句返回None</p>
<pre><code class="language-python">def sum(a,b):
	sum = a + b
	return sum

print (sum(1,2))

def sum(a,b):
	sum = a + b
	return
#返回none
print (sum(1,2))

</code></pre>
<h4 id="全局变量和局部变量">全局变量和局部变量</h4>
<p>定义在函数内部的变量只在局部作用域中使用，称为局部变量。</p>
<p>定义在函数外的拥有全局作用域，称为全局变量。</p>
<pre><code class="language-python"># 外面的total就是一个全局变量
total = 0
def sum(a,b):
	# 这个total就是一个局部变量
	total = a + b
	print (total)

print (total)


# 外面的total就是一个全局变量
total = 0
def sum(a,b):
	# 这个total就是一个局部变量
    global total
    total = a + b
    print (total)

sum(1,2)
print (total)
</code></pre>
<h4 id="函数名的应用">函数名的应用</h4>
<p>函数名是一个变量，但它是一个特殊的变量。</p>
<pre><code class="language-python">def hello():
	print ('helloworld')

#赋值给其他变量，这个变量也拥有了和这个函数一样的功能
hello2 = hello
hello()

#也可以和其他变量一样，用来作为函数的参数和函数的返回值
def func1(var):
    var()
    return var

hello3 = func1(hello)
hello3()
</code></pre>
<h3 id="内置函数">内置函数</h3>
<h4 id="内置函数的定义">内置函数的定义</h4>
<p>什么是内置函数，就是python给尼提供库，拿来直接用的函数，比如前面一直用的print，到python3.6.2，python一共提供了68个内置函数，我们来讲讲一些常用的内置函数。</p>
<h4 id="常用内置函数">常用内置函数</h4>
<pre><code class="language-python">#输出和输入
print ('hello')
str1 = input('请输入')
print (str1)


#获取对象的内存地址
a = 1
b = 1
print (id(a))
print (id(b))

#获取帮助
print (help(print))

#数字相关
#bool()  将给定的数据转成bool值，不传参返回False
print (bool(5))
#int()	将给定的数据转成int值，不穿参返回0
print (int('555'))
#float()  将给定的数据转成float值，不传参返回0.0
print (float('55.66'))

#sum 求和  min最小值 max最大值
list = [1,2,3,4]
print (sum(list))
print (min(list))
print (max(list))

#文件操作 open(file,mode='r') 常用模式 r 读  w从头覆盖写  a追加
r = open('1.txt')
print (r.read()) #全部读成一个字符串，同时把光标移动到最后
r.close()
#所以这里重头在读
r = open('1.txt')
print (r.readlines()) #按行分割成列表
r.close()

w = open('1.txt','w')
w.write('11111')
w.close()

w = open('1.txt','a')
w.write('11111')
w.close()
</code></pre>
<h3 id="面向对象1">面向对象1</h3>
<h4 id="面向对象的基本概念">面向对象的基本概念</h4>
<ul>
<li>我们之前学习的编程方式就是 面向过程的</li>
<li>面向过程、面向对象是两种不同的编程方式</li>
</ul>
<p>面向过程怎么做：</p>
<ol>
<li>
<p>收到一个需求，我们把完成需求的所有步骤，从头到尾逐步实现</p>
<ol>
<li>把某些功能独立的代码封装成一个又一个的函数</li>
<li>最后完成的代码就是顺序的调用不同的函数</li>
</ol>
</li>
</ol>
<figure data-type="image" tabindex="6"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566403081306.png" alt="1566403081306" loading="lazy"></figure>
<p>面向对象：</p>
<p>相比较函数，面向对象是更大的封装，根据职责或者说功能，在一个对象中去封装多个方法，你也可以理解为将函数进行分类</p>
<p>我们需要在面向过程的基础上，再学习一些面向对象的语法。</p>
<h4 id="类和对象">类和对象</h4>
<p>类：	是对一群 具有 相同特征或者行为的事物的一个统称，是抽象的，不能直接使用，类的特征 被称为 属性，类的行为被称为方法。</p>
<p>比如 类就相当于制造飞机的图纸，是一个模板，是负责用来创建对象的。比如飞机，飞机的长、宽、高就是飞机的特征也就是属性，比如飞机会飞就是飞机的行为，被称为方法。</p>
<p>对象： 是由类创建出来的一个具体存在，可以直接使用，比如我们用飞机的图纸制造出一台真正的飞机，那么这个飞机就有了我们图纸中设想的长、宽、高，然后有飞的方法。</p>
<p>所以，在程序开发中，应该</p>
<ul>
<li>先有类，再有对象</li>
<li>一个类可以创建多个对象</li>
<li>类中定义了的属性、方法，在对象创建后就会有对应的属性和方法</li>
</ul>
<h4 id="类的设计">类的设计</h4>
<ul>
<li>确定类名，分析整个业务流程，确定类名。</li>
<li>对对象的特征描述，通常可以定义成为属性</li>
<li>对象具有的行为，通常可以定义成方法</li>
</ul>
<p>练习1:</p>
<ol>
<li>
<p>小明今天18岁，身高1.75，每天早上跑步，会去吃东西</p>
</li>
<li>
<p>小美今年17岁，身高1.65，小美不跑步，喜欢吃东西</p>
<p>类名： Person</p>
<p>属性： name	age	height</p>
<p>行为： run()	eat()</p>
</li>
</ol>
<h4 id="定义简单的类">定义简单的类</h4>
<p>面向对象是更大的封装，在一个类中封装多个方法，就可以通过这个类创建出来的对象，直接调用这些方法。</p>
<pre><code class="language-python">class 类名:
	def 方法1(self,参数列表):
		pass
	
	def 方法2(self,参数列表):
		pass
</code></pre>
<p>方法的定义格式和之前学习过的函数的定义方式几乎一样，但是区别在于第一个参数必须是self，稍后介绍self</p>
<p>创建对象</p>
<pre><code>对象变量 = 类名()
</code></pre>
<h4 id="第一个面向对象程序">第一个面向对象程序</h4>
<p>需求： 小狗爱吃骨头，小狗旺旺叫</p>
<p>类名：	dog</p>
<p>方法：	eat()	wang()</p>
<pre><code class="language-python">class Dog:
    &quot;&quot;&quot;这是一个狗&quot;&quot;&quot;

    def eat(self):
        print(&quot;小狗吃骨头&quot;)

    def wang(self):
        print(&quot;旺旺&quot;)

tom = Dog()
tom.eat()
tom.wang()
</code></pre>
<h4 id="self">Self</h4>
<blockquote>
<p>由哪一个对象调用的方法，方法内的self就是哪一个对象的引用</p>
</blockquote>
<pre><code class="language-python">class Dog:
	
	def eat(self):
		print ('%s 吃骨头' % self.name)
		
tom = Dog()
tom.name = 'Tom'
tom.eat()

kat = Dog()
kat.name = 'kat'
kat.eat()
</code></pre>
<p>在类的外部，通过 对象.，来访问对象的属性和方法</p>
<p>在类的内部，通过self.  ,来访问对象的属性和方法</p>
<h4 id="初始化方法">初始化方法</h4>
<p>如果先调用方法，再设置属性，会如何呢</p>
<pre><code class="language-python">tom = Dog()
tom.eat()
tom.name = 'Tom'
# 会报错，对象没有 name的属性
</code></pre>
<p>所以，在开发过程中，不推荐在类的外部给对象增加属性，可能会存在这样的问题，对象包含属性，应该封装在类的内部</p>
<blockquote>
<p><code>__init__</code> 专门用来定义一个类具有哪些属性的方法，当使用类名来创建对象时，这个方法里面的内容就会自动运行</p>
</blockquote>
<pre><code class="language-python">class Dog:

    def __init__(self):
        print(&quot;初始化方法&quot;)
       
tom = Dog()
</code></pre>
<p>在开发中，如果希望在创建对象的同时，就设置对象属性，可以给init设置参数</p>
<pre><code class="language-python">class Dog:
	
	def __init__(self,name):
		print ('这是初始化方法')
		self.name = name
	
	def eat(self):
		print ('%s 吃骨头' % self.name)
        
tom = Dog('tom')
tom.eat()
</code></pre>
<h4 id="内置方法">内置方法</h4>
<blockquote>
<p><code>__del__</code> 对象从内存中销毁前，会被自动调动</p>
<p><code>__str__</code> 返回对象的描述信息，print函数输出使用，默认情况下， 会输出这个变量引用的对象是由哪一个类对象创建的，以及内存中的地址</p>
</blockquote>
<pre><code class="language-python">class Dog:

    def __init__(self, name):

        self.name = name

        print(&quot;%s 创建了&quot; % self.name)

    def __del__(self):

        print(&quot;%s 销毁了&quot; % self.name)
        
    def __str__(self):
        return &quot;我是小狗：%s&quot; % self.name

# tom 是一个全局变量
tom = Dog(&quot;Tom&quot;)

print (tom)
# del 关键字可以删除一个对象
del tom

</code></pre>
<h4 id="私有属性和私有方法">私有属性和私有方法</h4>
<blockquote>
<p>私有属性: 只在对象内部使用，不能在外部使用的属性</p>
<p>私有方法: 只在对象内部使用，不能在外部使用的方法</p>
</blockquote>
<p>在创建属性和方法时，在前面加上两个下划线即可</p>
<pre><code class="language-python">class Dog:
	
	def __init__(self,name):
		print ('这是初始化方法')
		self.__name = name
	
	def __eat(self):
		print ('%s 吃骨头' % self.name)
        
tom = Dog('tom')
print (tom.name)
tom.eat()
</code></pre>
<h3 id="面向对象2">面向对象2</h3>
<h4 id="面向对象的三大特征">面向对象的三大特征</h4>
<ul>
<li>封装，根据职责将属性和方法封装到一个抽象的类中</li>
<li>继承，实现代码的重用，相同的代码不需要重复的编写</li>
<li>多态，不同的对象调用相同的方法，产生不同的执行结果</li>
</ul>
<h4 id="封装">封装</h4>
<blockquote>
<p>封装是面向对象编程的 一大特点，将属性和方法封装到一个抽象的类中，外界使用它时就创建对象，然后让对象调用方法</p>
</blockquote>
<p>实例:</p>
<ul>
<li>小华体重100公斤</li>
<li>小华每次跑步减肥 1 公斤</li>
<li>小华每次吃东西体重就会 增加2公斤</li>
</ul>
<pre><code class="language-python">class Person:
	def __init__(self, name, weight):
	
		self.name = name
		self.weight = weight
		
	def __str__(self):
		
		return &quot;我是 %s，我的体重是 %d&quot; % (self.name,self.weight)
		
	def run(self):
		
		self.weight = self.weight - 1
		
	def eat(self):
	
		self.weight = self.weight + 2
		
hua = Person('小华',100)
hua.eat()
hua.run()
hua.run()
print (hua)
</code></pre>
<h4 id="继承的基础语法">继承的基础语法</h4>
<blockquote>
<p>继承后，子类拥有父类的所有方法和属性</p>
</blockquote>
<pre><code class="language-python">class 类名(父类名):
	pass
</code></pre>
<pre><code class="language-python">class Person:
	def __init__(self, name, weight):
	
		self.name = name
		self.weight = weight
		
	def __str__(self):
		
		return &quot;我是 %s，我的体重是 %d&quot; % (self.name,self.weight)
		
	def run(self):
		
		self.weight = self.weight - 1
		
	def eat(self):
	
		self.weight = self.weight + 2

class Student(Person):
	
	pass
	
hua = Student('小华',100)
hua.eat()	
hua.run()
hua.run()
print (hua)
</code></pre>
<h4 id="方法的重写">方法的重写</h4>
<blockquote>
<p>当父类的方法实现不能满足子类需求的时候，可以对方法进行 重写</p>
</blockquote>
<pre><code class="language-python">class Person:
	def __init__(self, name, weight):
	
		self.name = name
		self.weight = weight
		
	def __str__(self):
		
		return &quot;我是 %s，我的体重是 %d&quot; % (self.name,self.weight)
		
	def run(self):
		
		print ('run -1')
		self.weight = self.weight - 1
		print (self.weight)
		
	def eat(self):
		print ('eat +2')
		self.weight = self.weight + 2
		print (self.weight)
		
class Student(Person):
	
	def eat(self):
		
		print ('eat + 3')
		self.weight = self.weight + 3
		print (self.weight)
		
		# super(Student, self).eat()
hua = Student('小华',100)
hua.eat()	
hua.run()
print (hua)
</code></pre>
<h4 id="多继承">多继承</h4>
<blockquote>
<p>子类可以拥有多个父类，可以同多个父类中继承属性和方法</p>
</blockquote>
<pre><code class="language-python">class 子类名(子类A,子类B):
	pass
</code></pre>
<pre><code class="language-python">class Student:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight

    def __str__(self):
        return &quot;我是 %s，我的体重是 %d&quot; % (self.name, self.weight)

    def run(self):
        print('run')
        self.weight = self.weight - 1
        print(self.weight)

    def eat(self):

        self.weight = self.weight + 2


class Man:

    def __init__(self):
        print ('我是一个男人')

class ManStudent(Man,Student):

    pass

xiaohua = ManStudent()
</code></pre>
<p>如果 不同的父类中存在同名的方法，那么子类对象在调用方法时，会按照继承顺序来查找，先查找自己的，然后查找第一个父类，然后查找第二个父类，但是，不要这么去做，在开发过程要尽量避免这种情况的发生。</p>
<h4 id="object类">object类</h4>
<p>在python3里，如果没有指定父类，会默认使用object类来作为该类的父类，object类已经提供了一些内置的属性和方法供我们使用，但是在python2里，没有这种设定，为了保证代码能在Python2和python3中同时使用，建议统一继承object</p>
<pre><code class="language-python">class 类型(object):
	pass
</code></pre>
<h4 id="多态">多态</h4>
<blockquote>
<p>在多态不同的子类对象调用的父类方法，产生不同的执行结果</p>
<p>如len()函数就是一个多态的例子，传入list和传入str都会返回长度</p>
</blockquote>
<pre><code class="language-python">class Animal(object):


    def animal_talk(self,obj):

        obj.talk()


class Cat(Animal):

    def talk(self):

        print ('miaomiaomiao')

class Dog(Animal):

    def talk(self):

        print ('wangwangwang')

tom = Cat()
wangcai = Dog()

a = Animal()
a.animal_talk(tom)
a.animal_talk(wangcai)
</code></pre>
<h3 id="面向对象3">面向对象3</h3>
<h4 id="实例属性和实例方法">实例属性和实例方法</h4>
<ul>
<li>创建的对象叫做类的实例，这个动作叫做实例化</li>
<li>对象的属性，叫做实例属性</li>
<li>对象调用的方法叫做实例方法</li>
<li>在对象中各自都拥有自己的实例属性</li>
</ul>
<figure data-type="image" tabindex="7"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566659732324.png" alt="1566659732324" loading="lazy"></figure>
<h4 id="类属性和类方法">类属性和类方法</h4>
<blockquote>
<p>在python中 一切皆为对象</p>
</blockquote>
<ul>
<li>类也是一个特殊的对象，被叫做类对象</li>
<li>在程序运行中，类也会被加载到内存中，但是只有一份</li>
<li>所以在类中除了定义实例的属性和方法外，类对象还可以拥有自己的属性和方法</li>
<li>通过类名的方式就可以访问类的属性或者类的方法</li>
</ul>
<pre><code class="language-python">class Dog(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Dog.count = Dog.count + 1

dog1 = Dog('xiaoming')
dog2 = Dog('xiaohua')
dog3 = Dog('xiaoting')

print(Dog.count)
Dog.printcount()
</code></pre>
<p>类方法</p>
<pre><code class="language-python">@classmethod
def 类方法名(cls):
    pass
</code></pre>
<ul>
<li>classmethod是修饰器，告诉解释器这是一个类方法</li>
<li>类方法的第一个参数是cls（用其他也可以，但是习惯用这个）</li>
</ul>
<pre><code class="language-python">class Dog(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Dog.count = Dog.count + 1


    @classmethod
    def printcount(cls):
        print (cls.count)


dog1 = Dog('xiaoming')
dog2 = Dog('xiaohua')
dog3 = Dog('xiaoting')

print(Dog.count)
Dog.printcount()
</code></pre>
<h4 id="静态方法">静态方法</h4>
<blockquote>
<p>在开发过程时，如果既不需要访问实例属性、也不需要访问类属性，就可以把这个方法封装成一个静态方法</p>
</blockquote>
<pre><code class="language-python">class Dog(object):
    count = 0

    def __init__(self, name):
        self.name = name
        Dog.count = Dog.count + 1
        Dog.printdog()


    @staticmethod
    def printdog():
        print ('我是一只狗')


dog1 = Dog('xiaoming')
</code></pre>
<h4 id="方法总结">方法总结</h4>
<ul>
<li>如果需要方法需要访问实例属性，封装为实例方法</li>
<li>如果方法不要访问实例属性，需要访问类属性，封装为类方法</li>
<li>如果方法不要访问实例属性也不需要访问类属性，封装为静态方法</li>
</ul>
<h4 id="单例设计模式">单例设计模式</h4>
<blockquote>
<p>设计模式是前人工作的总结和提炼，针对某一特定问题的成熟的解决方案，比如我要实现一个音乐播放器，那么我在这台电脑上只允许创建一个窗口</p>
<p>单例设计模式，让类创建的对象，在系统中只有唯一的一个实例，每次执行类名（）返回的对象，内存地址都是相同的，也就是同一个对象</p>
</blockquote>
<p>在使用类名() 创建对象时，python的解释器首先会调用 <code>__new__</code>方法对对象分配空间，这个方法是由object基础提供的内置的静态方法，主要作用有两个，分配内存空间，返回对象的引用，为了实现单例模式，我们要重写这个方法</p>
<pre><code class="language-python">class QQMusicPlayer(object):

    # 定义类属性记录单例对象引用
    instance = None

    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否已经被赋值
        if cls.instance is None:
            cls.instance = super().__new__(cls)

        # 2. 返回类属性的单例引用
        return cls.instance
</code></pre>
<p>依然存在一个问题，每次类名()创建对象的时候，依然会执行init方法，我们需要再做一个判断 6786</p>
<pre><code class="language-python">class QQMusicPlayer(object):

    # 定义类属性记录单例对象引用
    instance = None
	flag = 0
    
    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否已经被赋值
        if cls.instance is None:
            cls.instance = super().__new__(cls)

        # 2. 返回类属性的单例引用
        return cls.instance
    
   def __init__(self):
    	if QQMusicPlayer.flag == 0:
            print(&quot;初始化音乐播放器&quot;)
            QQMusicPlayer.flag = 1
      
</code></pre>
<h3 id="异常">异常</h3>
<h4 id="异常的概念">异常的概念</h4>
<blockquote>
<p>程序在运行过程中，如果遇到一个错误，那么就会停止程序的运行，并且提示错误信息，这就是异常，提示错误信息的动作，我们通常称为抛出异常</p>
</blockquote>
<h4 id="捕获异常">捕获异常</h4>
<p>在开发过程中，如果对某些代码的执行不能确定是否能正确运行，那么就可以捕获异常，通过这种方式可以对突发事件做集中的处理，从而保证程序的稳定性和健壮性</p>
<pre><code class="language-python">try:
	尝试执行的代码
except:
	出现错误后的处理	
</code></pre>
<pre><code class="language-python">try:
	num = int(input('请输入整数'))
except:
	print ('请输出整数哦')
</code></pre>
<h4 id="按错误类型执行代码">按错误类型执行代码</h4>
<pre><code class="language-python">try:
	num = int(input('请输入整数'))
	result = 10 / num
	print (result)
except valueError:
	print ('请输入正确的整数')
except ZeroDivisionError:
    print(&quot;除 0 错误&quot;)

# 在开发中预判都所有的错误还是有一定的难度，如果希望程序无论出现任何错误都可以继续执行，那么可以再增加一个except
except Exception as result:
    print(&quot;未知错误 %s&quot; % result)
</code></pre>
<h4 id="传递异常">传递异常</h4>
<blockquote>
<p>当函数/方法执行出现异常时，会将异常一直传递到函数/方法的调用方，直到主程序，如果在主程序中，都没有异常处理，程序才会被终止</p>
<p>所以，可以在主程序中捕获异常，而不需要在代码中加大量的代码</p>
</blockquote>
<pre><code class="language-python">class Dog:

    def chu(self):
        print (10/0)

try:
tom = Dog()
tom.chu()
except:
    pass

    
</code></pre>
<h4 id="主动抛出异常">主动抛出异常</h4>
<blockquote>
<p>在python中提供了异常类，在开发过程中，在某些特定的情况下，我们希望抛出一个异常</p>
</blockquote>
<pre><code class="language-python">a = 0 
if a == 0:
	raise RuntimeError('运行异常')
   
</code></pre>
<h3 id="模块和包">模块和包</h3>
<h4 id="模块和包的概念">模块和包的概念</h4>
<blockquote>
<p>每个以py为结为的文件都是一个模块</p>
<p>包是包含多个模块的文件夹</p>
</blockquote>
<h4 id="导入模块">导入模块</h4>
<pre><code class="language-python"># 导入整个模块,导入后可以使用模块提供的工具，而不需要通过模块名
import 模块1
import 模块2

# 导入模块的部分工具
from 模块1 import 工具名
</code></pre>
<pre><code class="language-python">import random

# 生成随机数
num = random.randint(0, 100)

print(num)
</code></pre>
<h4 id="pip-安装第三方模块">pip 安装第三方模块</h4>
<p>我们常用的知名的团队开发的模块和包，我们只需要知道怎么去安装和使用它们就可以了，避免重复造轮子，包括我们后面要学习的pyqt django都是现成的模块</p>
<pre><code class="language-python">pip install 模块名
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP协议基础知识]]></title>
        <id>https://childlike2333.github.io/post/http-xie-yi-ji-chu-zhi-shi/</id>
        <link href="https://childlike2333.github.io/post/http-xie-yi-ji-chu-zhi-shi/">
        </link>
        <updated>2020-03-18T14:46:47.000Z</updated>
        <content type="html"><![CDATA[<h4 id="http协议-超文本传输协议-基于tcpip通讯协议来传递数据">HTTP协议 超文本传输协议 基于TCP/IP通讯协议来传递数据</h4>
<p>主要特点：</p>
<ol>
<li>
<p>简单快速</p>
</li>
<li>
<p>灵活</p>
</li>
<li>
<p>无连接</p>
</li>
<li>
<p>无状态</p>
</li>
<li>
<p>支持B/S及C/S模式</p>
</li>
</ol>
<h4 id="url-统一资源定位符">URL 统一资源定位符</h4>
<blockquote>
<p>http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</p>
</blockquote>
<ol>
<li>
<p>http: 协议名称</p>
</li>
<li>
<p>www.aspxfans.com     域名部分</p>
</li>
<li>
<p>8080     端口部分</p>
</li>
<li>
<p>/news/     虚拟目录部分</p>
</li>
<li>
<p>index.asp     文件名部分</p>
</li>
<li>
<p>#到最后     锚部分</p>
</li>
<li>
<p>？到#中间的部分     参数部分</p>
</li>
</ol>
<h4 id="http-请求消息request格式包括">HTTP 请求消息Request，格式包括</h4>
<ol>
<li>
<p>请求行     请求类型，访问的资源及HTTP版本（不同请求区别在与请求行的 GET/POST请求头）</p>
</li>
<li>
<p>请求头部     说明服务器要使用的附加信息，浏览器相关的内容，由浏览器来自己定义</p>
</li>
<li>
<p>空行     请求头部后面的空行是必须的</p>
</li>
<li>
<p>请求数据     请求数据如name=多少 id等于多少等等</p>
</li>
</ol>
<pre><code>GET /562f25980001b1b106000338.jpg HTTP/1.1
Host    img.mukewang.com
User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
Accept    image/webp,image/*,*/*;q=0.8
Referer    http://www.imooc.com/
Accept-Encoding    gzip, deflate, sdch
Accept-Language    zh-CN,zh;q=0.8、
</code></pre>
<h4 id="http响应消息response格式包括">HTTP响应消息Response,格式包括</h4>
<ol>
<li>
<p>状态行，由HTTP协议版本号、状态码、状态消息组成</p>
</li>
<li>
<p>消息报头，用来说明客户端要使用的一些附加信息</p>
</li>
<li>
<p>空行</p>
</li>
<li>
<p>响应正文，服务器返回给客户端的文本信息</p>
</li>
</ol>
<p>HTTP/1.1 200 OK<br>
Date: Fri, 22 May 2009 06:07:21 GMT<br>
Content-Type: text/html; charset=UTF-8</p>
<pre><code>&lt;html&gt;
      &lt;head&gt;&lt;/head&gt;
      &lt;body&gt;
            &lt;!--body goes here--&gt;
      &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="http之状态码三位数字组成第一个数字定义响应的类别">HTTP之状态码：三位数字组成，第一个数字定义响应的类别</h4>
<p>1xx：指示信息--表示请求已经接受，继续处理</p>
<p>2xx：成功，表示请求已被成功接收、理解、接受</p>
<p>3xx:  重定向，要完成请求必须进行更进一步的操作</p>
<p>4xx: 客户端错误，请求有语法错误或请求无法实现</p>
<p>5xx:  服务器端错误，服务器未能实现合法的请求</p>
<h4 id="常见状态码">常见状态码</h4>
<p>200 OK     客户端请求成功</p>
<p>400 Bad Request     客户端请求有语法错误，不能被服务器所理解</p>
<p>403 Forbidden     服务器收到请求，但是拒绝提供服务</p>
<p>404 Not Found     请求资源不存在，输入了错误的URL</p>
<p>500 Internal Server Error     服务器发生了不可预期的错误</p>
<p>503 Server Unavailable     服务器当前不能处理客服端的请求，一段时间后可能恢复正常</p>
<h4 id="http请求方法">HTTP请求方法：</h4>
<p>1.0定义了三种请求方法：</p>
<p>GET：请求指定的页面信息，并返回实体主体</p>
<p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）</p>
<p>HEAD：类似get请求，只不过返回的响应中没有具体的内容，用于获取报头</p>
<h4 id="http工作原理">HTTP工作原理：</h4>
<p>工作步骤：</p>
<ol>
<li>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口，建立一个TCP套接字连接</p>
</li>
<li>
<p>发送HTTP请求，即上面的上面的request等</p>
</li>
<li>
<p>服务器接受请求并返回HTTP响应，Web服务器解析请求，定位请求资源，即response</p>
</li>
<li>
<p>释放连接TCP</p>
</li>
<li>
<p>客户端解析服务器返回的HTML内容</p>
</li>
</ol>
<h4 id="浏览器输入url按下回车之后会经历以下流程">浏览器输入URL，按下回车之后会经历以下流程：</h4>
<ol>
<li>
<p>浏览器像DNS服务器请求解析该URL中的域名所对应的IP地址</p>
</li>
<li>
<p>解析IP地址后，根据ip地址和端口，和服务器建立TCP连接</p>
</li>
<li>
<p>浏览器发出读取文件的HTTP请求，改请求报文作为TCP三次握手的第三个报文的数据发给服务器；</p>
</li>
<li>
<p>服务器对浏览器请求做出响应，并把对应的html文本发送给浏览器；</p>
</li>
<li>
<p>释放TCP连接</p>
</li>
<li>
<p>浏览器将该html文本并显示内容</p>
</li>
</ol>
<h4 id="get-post的区别">GET、POST的区别</h4>
<ol>
<li>
<p>GET会将参数附加到地址上，而POST请求不会</p>
</li>
<li>
<p>浏览器和服务器对URL长度一般来说会有限制，所以采用GET方法提交的时候，传输数据就会受到URL长度的限制。</p>
</li>
<li>
<p>POST的安全性要比GET的安全性高，通过GET提交数据，数据会明文显示在URL上</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx代理配置https源站并支持quic协议]]></title>
        <id>https://childlike2333.github.io/post/nginx-dai-li-pei-zhi-https-yuan-zhan-bing-zhi-chi-quic-xie-yi/</id>
        <link href="https://childlike2333.github.io/post/nginx-dai-li-pei-zhi-https-yuan-zhan-bing-zhi-chi-quic-xie-yi/">
        </link>
        <updated>2020-03-18T14:46:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code>events {
    worker_connections  1024;
}

http {
    include mime.types; 
    default_type application/octet-stream;
    sendfile on;
    keepalive_timeout 65;

server {
            listen       443 ssl;
            add_header alt-svc 'quic=&quot;:443&quot;; ma=2592000; v=&quot;44,43,39&quot;';
            server_name  wangsu.tplat.top;
            ssl_certificate    2551488_wangsu.tplat.top.pem;
            ssl_certificate_key  2551488_wangsu.tplat.top.key;
            ssl_session_cache    shared:SSL:1m;
            ssl_session_timeout  5m;
            ssl_ciphers  HIGH:!aNULL:!MD5;
            ssl_prefer_server_ciphers  on;
            error_page   500 502 503 504  /50x.html;
            location / {
                proxy_pass  http://10.8.210.30:61030;
            }
            location /static/ {
                alias  /home/TPlat/TPlat/static/;
            }
        }

server {
    listen 80;
    server_name wangsu.tplat.top;
      location / {
                proxy_pass  http://10.8.210.30:61030;
            }
     }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FQA——Tools]]></title>
        <id>https://childlike2333.github.io/post/fqa-tools/</id>
        <link href="https://childlike2333.github.io/post/fqa-tools/">
        </link>
        <updated>2020-03-18T14:37:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="eclipse关联git插件">eclipse关联git插件</h3>
<ol>
<li>首先windows电脑已经安装了git插件</li>
<li>在外面找一个文件夹git一份代码</li>
<li>然后在eclipse中新建一个 robot-framework项目</li>
<li>右键项目-选 team小组-共享项目-在弹出框中选git</li>
<li>弹出框中的 repository 点击create，选择刚才在外面git代码的路径，完成即可</li>
</ol>
<h3 id="eclipse导入一个git的django项目">eclipse导入一个git的django项目</h3>
<ol>
<li>在项目路径 右键导入 选择git project from git</li>
<li>选择clone url</li>
<li>填入路径、账号密码等信息，作为一个普通项目导入</li>
<li>右键项目，pydev-设置这个项目为 python项目 django项目 并作为源路径使用</li>
<li>右键项目，属性, pydev/django，设置TPlat/manage.py,设置manage路径就可以使用django跑服务</li>
</ol>
<h3 id="eclipse微软雅黑consolas字体设置">eclipse微软雅黑+Consolas字体设置</h3>
<ul>
<li>下载两种字体混合语言包，复制到c:/windows/fonts</li>
<li>首选项-外观-颜色和字体-文本字体 选择字体为yahei consolas</li>
</ul>
<h3 id="eclipse设置所有txt文件用utf-8编码打开">eclipse设置所有txt文件用utf-8编码打开</h3>
<p>首选项-常规-工作空间，设置文本默认打开编码（兼容远程模式）</p>
<h3 id="eclipse配置git插件">eclipse配置git插件</h3>
<ol>
<li>安装git插件 Help - Install New Software - 点击Add添加。 软件名字：egit   http://download.eclipse.org/egit/updates</li>
<li>勾选 全部. 点击Next. 继续等待，这个时间会比较久，请耐心等待。新的页面出来之后，选择install 安装</li>
</ol>
<h3 id="eclipse配置robot插件">eclipse配置robot插件</h3>
<ol>
<li>Help - Install New Software - 点击Add添加。 RED地址：http://master.dl.sourceforge.net/project/red-robot-editor/repository点击OK之后，名字加个robot吧。等待</li>
<li>勾选 Robot Framework IDE. 点击Next. 继续等待，这个时间会比较久，请耐心等待。新的页面出来之后，选择install 安装。</li>
<li>安装完成之后，开始配置RF标识，关键字，变量的自动补全。 windows - preference - RobotFramework - Editor - Content Assitant 加上如下内容： .abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$@&amp;*:</li>
</ol>
<h3 id="git拉取远程分支">git拉取远程分支</h3>
<ol>
<li>找一个目录用来拉取</li>
<li>git init   初始化一下</li>
<li>git remote add origin git@gitlab:root/wscaddytest.git   与远程仓库建立连接</li>
<li>git pull origin dev_yuzt     拉取分支</li>
</ol>
<h3 id="securecrt标签显示主机名">secureCRT标签显示主机名</h3>
<p>secureCRT标签显示主机名：<br>
把option中的Enable keypad mode switching这一项不要打钩即可</p>
<h3 id="windows后台运行bat">Windows后台运行bat</h3>
<pre><code>@echo off 　　
　　if &quot;%1&quot; == &quot;h&quot; goto begin 
　　    mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;%~nx0 h&quot;,0)(window.close)&amp;&amp;exit 
　　:begin
</code></pre>
<h3 id="windows命令行返回字符编码异常">Windows命令行返回字符编码异常</h3>
<p>windows cmd返回数据，print报错，字符编码问题：<br>
windows cmd编码如果为gbk	 python解析时要 f.read().decode('gbk')<br>
windows命令行执行命令的返回时要检索，str.find 也要转成gbk，不然rf会报错</p>
<h3 id="windows查看路由">Windows查看路由</h3>
<p>route print<br>
显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface<br>
tracert -参数 ip(或计算机名)<br>
跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。</p>
<h3 id="只单独调整win10字体大小的方法">只单独调整win10字体大小的方法</h3>
<ul>
<li>单击Windows开始菜单，在搜索框中输入“regedit”，在点击搜索结果的“regedit运行命令”，就会打开注册表</li>
<li>按路径依次点开文件夹，找到WindowMetrics，路径为\HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics</li>
<li>在右侧找到IconFont，双击或右键修改，注意，只修改0000和0010后面的值。Windows默认的字体大小为9号，改为12号最合适。CaptionFont活动、非活动窗口字体； IconFont图标字体；   MessageFont消息框字体；SmCaptionFont调色板标题字体 ，双击那个区域，修改</li>
</ul>
<h3 id="如何用git添加eclipse的robot项目">如何用git添加eclipse的robot项目</h3>
<ul>
<li>右键根目录-导入-复制项目的地址 配置完成</li>
<li>导入来日文件夹或者归档文件的项目，层级选深入一级</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FQA——Python]]></title>
        <id>https://childlike2333.github.io/post/fqa-python/</id>
        <link href="https://childlike2333.github.io/post/fqa-python/">
        </link>
        <updated>2020-03-18T14:32:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="django-gunicorn配置使用">Django-gunicorn配置使用</h3>
<ul>
<li>安装</li>
</ul>
<p>pip install gunicorn</p>
<p>在项目的setting注册应用  gunicorn</p>
<p>在manage.py所在目录下：</p>
<p>gunicorn TPlat.wsgi:application -b 10.8.210.30:61030</p>
<p>-b 指定运行ip及端口</p>
<p>--workers 8  启用8个线程来运行程序，一般看CPU的核数</p>
<p>--worker-class gevent  使用gevent异步工作模式来运行程序</p>
<p>使用前需要安装 pip install gevent</p>
<p>静态文件加载问题：<br>
在TPlat/urls.py中加入,注意位置</p>
<pre><code class="language-python">from django.contrib.staticfiles.urls import staticfiles_urlpatterns
urlpatterns = [
     url('^admin/', admin.site.urls),
]
urlpatterns += staticfiles_urlpatterns()
</code></pre>
<h3 id="layui弹出层下拉框遮挡问题">Layui弹出层，下拉框遮挡问题</h3>
<p>弹出层，会使用到layui-layer-content，在新增、修改按钮，弹出弹出层后，设置layui-layer-content的一个属性为</p>
<pre><code>$('#edit_ip').parent().attr('style','overflow:visible !important');
</code></pre>
<h3 id="linux多线程连接数据库时抛出异常">linux多线程连接数据库时抛出异常</h3>
<p>在linux下，多线程去连接数据库时会异常（windows下不会有这种情况）2006 mysql server has gone away<br>
需要先关闭旧的数据库连接</p>
<p><code>from django.db import close_old_connections</code></p>
<p>然后在进程开始后的第一句中,将旧的数据库连接关闭</p>
<p><code>close_old_connections()</code></p>
<h3 id="rf无法执行用例">RF无法执行用例</h3>
<p>在C:\Python27\Scripts 目录下建立一个pybot.bat<br>
@Echo off<br>
python -m robot.run %*</p>
<h3 id="rf无法获取w10管理员执行权限">RF无法获取w10管理员执行权限</h3>
<p>建立一个runrobot.bat,然后以管理员权限运行这个bat<br>
python C:\Python27\Scripts\ride.py</p>
<h3 id="robot命令执行优化">robot命令执行优化</h3>
<p>指定报告标题，运行整个目录下的suites<br>
robot --logtitle TestReport --reporttitle TestReport suites [目录]</p>
<h3 id="robot字典取值">robot字典取值</h3>
<p>&amp;{log_dict}[pid]    中间不需要加引号</p>
<h3 id="robot执行时编码异常">robot执行时编码异常</h3>
<p>reload(sys)<br>
sys.setdefaultencoding('utf8')</p>
<h3 id="str和unicode字符转换">str和unicode字符转换</h3>
<p>python str 和 unicode字符转换：<br>
unicode转化为str，采用encode 编码：<br>
str = u.encode('gbk')<br>
str转化为unicode ，采用decode 解码：<br>
unicode = s.decode('gbk')</p>
<h3 id="创建有顺序的字典">创建有顺序的字典</h3>
<pre><code class="language-python">import collections
dic = collections.OrderedDict()
</code></pre>
<h3 id="前端导出excel失败">前端导出excel失败</h3>
<p>因为ajax无法直接接收文件流</p>
<pre><code class="language-html">window.open('/export_excel/')
</code></pre>
<h3 id="获取当前路径">获取当前路径</h3>
<pre><code class="language-python">#获取当前路径
os.getcwd()
#组合路径
os.path.join(os.getcwd(),'lib','action_event.yaml')  
</code></pre>
<h3 id="linux在另一个进程中使用models">linux在另一个进程中使用models</h3>
<p>linux要在另一个进程中使用models 需要在文件的最前面导入这些：<br>
import django<br>
import os</p>
<p>os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;TPlat.settings&quot;)<br>
django.setup()</p>
]]></content>
    </entry>
</feed>